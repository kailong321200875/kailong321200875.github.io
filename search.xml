<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue-cli3.0多环境配置</title>
    <url>/vue-cli3-0%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>在日常开发中，我们通常会遇到不同环境的发包，所以在这里记录一下如何进行多环境配置。</p>
</blockquote>
<a id="more"></a>

<h2 id="新建环境配置文件"><a href="#新建环境配置文件" class="headerlink" title="新建环境配置文件"></a>新建环境配置文件</h2><blockquote>
<p>我们需要在项目的根目录下新建环境配置文件，在这里我们以 <code>development</code> 开发环境、 <code>production</code> 生产环境 <code>test</code> 测试环境为例</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200530174258.png" alt=""></p>
<blockquote>
<p>之后我们在每个文件中添加以下代码</p>
</blockquote>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'development'</span></span><br><span class="line">VUE_APP_CURENV = <span class="string">'dev'</span></span><br></pre></td></tr></table></figure>

<h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'production'</span></span><br><span class="line">VUE_APP_CURENV = <span class="string">'pro'</span></span><br></pre></td></tr></table></figure>

<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'test'</span></span><br><span class="line">VUE_APP_CURENV = <span class="string">'test'</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>配置完多环境文件之后，具体需要进行什么操作由各位看官们根据项目自行决定，这里不做过多的阐述。接下来我们还需要在 <code>package.json</code> 进行修改</p>
          </div>

<h2 id="修改-package-json-文件"><a href="#修改-package-json-文件" class="headerlink" title="修改 package.json 文件"></a>修改 package.json 文件</h2><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200530175026.png" alt=""></p>
<blockquote>
<p>以上修改为多环境的打包命令，如果需要发包 <code>测试环境</code> 只需执行以下命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>其他环境同理，如果嫌一个个输入命令比较麻烦，可以像我一样，使用 <code>npm run all</code> 进行三个环境的打包。</p>
          </div>

<h2 id="不同环境的包名"><a href="#不同环境的包名" class="headerlink" title="不同环境的包名"></a>不同环境的包名</h2><blockquote>
<p>因为默认打包都是 <code>dist</code> 包名，所以不是很好区分是哪个环境的包，所以我们在 <code>vue.config.js</code> 里面进行配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">outputDir: `dist-<span class="variable">$&#123;process.env.VUE_APP_CURENV&#125;</span>-<span class="variable">$&#123;formatTime(new Date(), 'yyyyMMddHHmmss')&#125;</span>`,</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>可根据自己的实际情况进行修改设置，这里只提供一个例子。这样，我们每次打包出来，就很好的区分了是哪个环境的包了。</p>
          </div>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>在日常开发中，多环境配置还是很实用的，有兴趣的可以去实践一下。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
        <tag>多环境</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插槽详解</title>
    <url>/vue%E6%8F%92%E6%A7%BD%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>插槽：简单理解就是组件内部留一个或多个的插槽位置，可供组件传对应的模板代码进去。插槽的出现，让组件变的更加灵活。今天就来记录一下插槽的一些用法。</p>
</blockquote>
<a id="more"></a>

<div class="note info">
            <p>本文章的内容是基于 <code>vue &gt;= 2.6.0</code>，在 <code>2.6.0</code> 中，官方为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在文档中的 <code>attribute</code>。所以，旧语法我们这里就不演示了，有兴趣的看官们可以自行百度一下。</p>
          </div>

<h2 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h2><blockquote>
<p>匿名插槽简单点理解就是，在组件中设置一个默认插槽入口，在组件的使用中，填充的内容将会自动填充在默认插槽中。</p>
</blockquote>
<blockquote>
<p>接下来我们来定义一个组件，在组件里面只有一个 <code>slot</code> 标签，也就是我们上面所说的匿名插槽，用来接收外部传进来的模版进行渲染。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 定义一个组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Child1'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-1&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/child-1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child1 from <span class="string">'./components/Child1'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Slot'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child1</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      name: <span class="string">'我是name'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200330094934.png" alt=""></p>
<blockquote>
<p>这样我们就实现了一个简单的匿名插槽用法。</p>
</blockquote>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><blockquote>
<p>顾名思义就是带名字的插槽，假如需要在组件内部预留多个插槽位置，就需要为插槽定义名字，指定插入的位置。</p>
</blockquote>
<blockquote>
<p>首先我们来改造下之前的代码，在组件内部新增 <code>name</code> 分别为 <code>header</code> 和 <code>footer</code> 的插槽。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot name=<span class="string">"header"</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot name=<span class="string">"footer"</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Child1'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-1&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div v-slot=<span class="string">"header"</span>&gt;&#123;&#123; header &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div v-slot=<span class="string">"footer"</span>&gt;&#123;&#123; footer &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/child-1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child1 from <span class="string">'./components/Child1'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Slot'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child1</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      name: <span class="string">'我是name'</span>,</span><br><span class="line">      header: <span class="string">'我是header'</span>,</span><br><span class="line">      footer: <span class="string">'我是footer'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200330100151.png" alt=""></p>
<div class="note warning">
            <p>需要注意的是，如果使用了 <code>v-slot</code> 就必须配合着 <code>template</code> 来使用，不然会报错。</p>
          </div>

<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><blockquote>
<p>在实际项目中，我们有可能要在父组件中访问子组件内部的数据，改如何去做呢？首席我们再来改造下上面的代码。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot v-bind:user=<span class="string">"user"</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot name=<span class="string">"header"</span> v-bind:age=<span class="string">"age"</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot name=<span class="string">"footer"</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Child1'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      user: <span class="string">'我是子组件的user'</span>,</span><br><span class="line">      age: <span class="string">'我是子组件的age'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-1&gt;</span><br><span class="line">      &lt;template v-slot:default=<span class="string">"user"</span>&gt;&#123;&#123; user.user &#125;&#125;&lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:header=<span class="string">"header"</span>&gt;&#123;&#123; header.age &#125;&#125;&lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:footer&gt;&#123;&#123; footer &#125;&#125;&lt;/template&gt;</span><br><span class="line">    &lt;/child-1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child1 from <span class="string">'./components/Child1'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Slot'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child1</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      name: <span class="string">'我是name'</span>,</span><br><span class="line">      header: <span class="string">'我是header'</span>,</span><br><span class="line">      footer: <span class="string">'我是footer'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200330102929.png" alt=""></p>
<blockquote>
<p>这样我们就实现了让插槽内容能够访问子组件中数据，进行模版渲染。</p>
</blockquote>
<div class="note warning">
            <p>需要注意的是，匿名插槽传值只能使用 <code>default</code> 进行接收。具名插槽传值，接收的名字要跟子组件那边定义的一样。</p>
          </div>

<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><blockquote>
<p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 <code>v-slot:header</code> 可以被重写为 <code>#header：</code></p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>关于 <code>vue</code> 插槽的作用，本文章基本上已经概述得差不多了，各位看官们可以自己在项目中去实践下。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>slot</tag>
        <tag>vue插槽</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件之间的通信</title>
    <url>/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<blockquote>
<p>组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。针对不同的使用场景，如何选择行之有效的通信方式？本文总结了vue组件间通信的几种方式，希望对看官们有些许帮助。</p>
</blockquote>
<a id="more"></a>

<h2 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h2><div class="note info">
            <p>下面我们来介绍一下父子通信的几种方式</p>
          </div>

<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote>
<p><code>props</code> 的通信方式，可以说是最常用的父子组件的通信方式了。父组件通过 <code>props</code> 的方式向子组件传递，由子组件进行接收，这样我们就可以在子组件中拿到从父组件传递过来的参数了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"changeNum"</span>&gt;点击修改子组件的值&lt;/el-button&gt;</span><br><span class="line">    &lt;chlid :num=<span class="string">"num"</span>&gt;&lt;/chlid&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Chlid from <span class="string">'./Child'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Parent'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Chlid</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeNum</span></span>() &#123;</span><br><span class="line">      this.num += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template style=<span class="string">"margin-top: 30px;"</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    子组件中的num: &#123;&#123; num &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Child'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Number,</span><br><span class="line">      default: () =&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/Video_2020-03-27_103633.gif" alt=""></p>
<div class="note warning">
            <p>使用 <code>props</code> 需要注意，不应该在一个子组件内部改变 prop，这样会破坏单向的数据绑定，导致数据流难以理解。如果有这样的需要，可以通过 data 属性接收或使用 computed 属性进行转换。</p>
          </div>

<h3 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h3><blockquote>
<p>那么，子组件如何向父组件通信呢，这时我们就需要用到 <code>$emit</code> 了，通过 <code>$emit</code> 发射一个事件，然后由父组件用 <code>v-on</code> 接收子组件传递过来的参数，我们把上面的代码稍微改造一下。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=<span class="string">"margin-top: 30px;"</span>&gt;</span><br><span class="line">    子组件中的num: &#123;&#123; num &#125;&#125;</span><br><span class="line">    &lt;el-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"changeParentNum"</span>&gt;点击修改父组件的值&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Child'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Number,</span><br><span class="line">      default: () =&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 事件发射</span><br><span class="line">    <span class="function"><span class="title">changeParentNum</span></span>() &#123;</span><br><span class="line">      const num = this.num + 1</span><br><span class="line">      // 定义一个事件名，并传递参数</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'changeParentNum'</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"changeNum"</span>&gt;点击修改子组件的值&lt;/el-button&gt;</span><br><span class="line">    &lt;chlid :num=<span class="string">"num"</span> @changeParentNum=<span class="string">"changeParentNum"</span>&gt;&lt;/chlid&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Chlid from <span class="string">'./Child'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Parent'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Chlid</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeNum</span></span>() &#123;</span><br><span class="line">      this.num += 1</span><br><span class="line">    &#125;,</span><br><span class="line">    // 接收从子组件传递过来的参数</span><br><span class="line">    changeParentNum(val) &#123;</span><br><span class="line">      this.num = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/Video_2020-03-27_105652.gif" alt=""></p>
<div class="note info">
            <p>这样我们就通过了 <code>props</code> 和 <code>$emit</code> 实现了一个简单的数据双向绑定</p>
          </div>

<h3 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h3><blockquote>
<p>或许我们会觉得这样发射事件过于繁琐了，所以我们再稍微改造一下，使用 <code>.sync</code> 修饰符进行子组件向父组件通信并实现数据双向绑定。同样，我们还是改造上面的代码。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div style=<span class="string">"margin-top: 30px;"</span>&gt;</span><br><span class="line">    子组件中的num: &#123;&#123; num &#125;&#125;</span><br><span class="line">    &lt;el-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"changeParentNum"</span>&gt;点击修改父组件的值&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Child'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: &#123;</span><br><span class="line">      <span class="built_in">type</span>: Number,</span><br><span class="line">      default: () =&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 事件发射</span><br><span class="line">    <span class="function"><span class="title">changeParentNum</span></span>() &#123;</span><br><span class="line">      const num = this.num + 1</span><br><span class="line">      // 使用 .sync 修饰符，需要使用 update，告诉父组件，我需要更新哪个值</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'update:num'</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"changeNum"</span>&gt;点击修改子组件的值&lt;/el-button&gt;</span><br><span class="line">    &lt;!-- 使用.sync修饰符进行数据接收并更新 --&gt;</span><br><span class="line">    &lt;chlid :num.sync=<span class="string">"num"</span>&gt;&lt;/chlid&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Chlid from <span class="string">'./Child'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Parent'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Chlid</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeNum</span></span>() &#123;</span><br><span class="line">      this.num += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/Video_2020-03-27_105652.gif" alt=""></p>
<h2 id="非父子组件之间的通信"><a href="#非父子组件之间的通信" class="headerlink" title="非父子组件之间的通信"></a>非父子组件之间的通信</h2><div class="note info">
            <p>讲完父子组件的几种通信方式，我们来在讲讲非父子组件之间的通信方式。也可以叫做兄弟组件的通信方式</p>
          </div>

<h3 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h3><blockquote>
<p>对于比较小型的项目，可以使用 <code>eventBus</code>。可以实现任意两个组件间的通信。它的实现思想也很好理解，在要相互通信的两个组件中，都引入同一个新的 <code>vue</code> 实例，然后在两个组件中通过分别调用这个实例的事件触发和监听来实现通信。对于 <code>eventBus</code> 我们可以自己手动创建，也可以通过引入插件的方式。这里我们主要讲插件的这种方式。</p>
</blockquote>
<blockquote>
<p>首先我们需要安装下 <code>vue-bus</code> 这个插件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-bus --save</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后在 <code>main.js</code> 里面引入，这样我们在任意的 <code>vue</code> 实例中都能直接调用了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import VueBus from <span class="string">'vue-bus'</span> // bus总线</span><br><span class="line">Vue.use(VueBus)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// brother1组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-button <span class="built_in">type</span>=<span class="string">"primary"</span> @click=<span class="string">"changeNum"</span>&gt;点击修改brother2组件的值&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Brother1'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span></span>() &#123;</span><br><span class="line">    // 组件销毁之前需要清除bus</span><br><span class="line">    this.<span class="variable">$bus</span>.<span class="variable">$off</span>(<span class="string">'changeNum'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeNum</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$bus</span>.<span class="variable">$emit</span>(<span class="string">'changeNum'</span>, this.num += 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// brother2组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    brother1传递过来的值：&#123;&#123; num &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Brother2'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>() &#123;</span><br><span class="line">    // 声明接收事件</span><br><span class="line">    this.<span class="variable">$bus</span>.<span class="variable">$on</span>(<span class="string">'changeNum'</span>, (val) =&gt; &#123;</span><br><span class="line">      this.num = val</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行效果如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/Video_2020-03-27_122023.gif" alt=""></p>
<div class="note warning">
            <p>使用 <code>eventBus</code> 需要注意的是在组件销毁的时候，需要关闭接收事件。</p>
          </div>

<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><div class="note info">
            <p>如果不是特别必要的，可以不引入vuex，所以我们这里也不讲vuex是如何进行组件通信的，有兴趣的看官可以自行百度。</p>
          </div>

<h2 id="嵌套组件之间的通信"><a href="#嵌套组件之间的通信" class="headerlink" title="嵌套组件之间的通信"></a>嵌套组件之间的通信</h2><div class="note info">
            <p>在实际项目中，我们还有可能会遇到过深层次的嵌套组件之间的通信，如果使用 <code>props</code> 一直传递接收下去，未免显得太过沉重了，所以我们可以使用以下几个方法进行嵌套组件的通信。</p>
          </div>

<h3 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs / $listeners"></a>$attrs / $listeners</h3><blockquote>
<p>可能很多人都对这两个属性不了解，我们来看下官方的解释：</p>
</blockquote>
<ul>
<li>$attrs</li>
</ul>
<blockquote>
<p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</p>
</blockquote>
<ul>
<li>$listeners</li>
</ul>
<blockquote>
<p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</p>
</blockquote>
<blockquote>
<p>以下例子，我们准备了几个参数传递下去，并且准备了两个方法，一个加了 <code>native</code> 原生修饰符，一个是非原生事件，然后看看嵌套组件之间的参数传递结果</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;child-com-1</span><br><span class="line">      :params1=<span class="string">"params1"</span></span><br><span class="line">      :params2=<span class="string">"params2"</span></span><br><span class="line">      :params3=<span class="string">"params3"</span></span><br><span class="line">      :params4=<span class="string">"params4"</span></span><br><span class="line">      @event1.native=<span class="string">"event1"</span></span><br><span class="line">      @event2=<span class="string">"event2"</span></span><br><span class="line">    &gt;&lt;/child-com-1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildCom1 from <span class="string">'./components/com-3/ChildCom1'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Corresponded'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildCom1</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      params1: <span class="string">'javaScript'</span>,</span><br><span class="line">      params2: <span class="string">'html'</span>,</span><br><span class="line">      params3: <span class="string">'css'</span>,</span><br><span class="line">      params4: <span class="string">'vue'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">event1</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'我是有native原生事件修饰符的event1事件'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">event2</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">'我是非原生事件event2'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后在第一级的子组件里面，用 <code>props</code> 来接收一下传递过来的 <code>params1</code> 参数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 第一级子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;嵌套组件传递过来的参数：&#123;&#123; <span class="variable">$attrs</span> &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;child-com-2 v-bind=<span class="string">"<span class="variable">$attrs</span>"</span> v-on=<span class="string">"<span class="variable">$listeners</span>"</span>&gt;&lt;/child-com-2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildCom2 from <span class="string">'./ChildCom2'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'ChildCom1'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildCom2</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  // 用props接收params1参数</span><br><span class="line">  props: &#123;</span><br><span class="line">    params1: &#123;</span><br><span class="line">      <span class="built_in">type</span>: String,</span><br><span class="line">      default: () =&gt; <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>() &#123;</span><br><span class="line">    console.log(this.<span class="variable">$attrs</span>)</span><br><span class="line">    console.log(this.<span class="variable">$listeners</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以在 <code>child-com-1</code> 组件看到，用 <code>props</code> 接收的属性和  <code>native</code> 修饰的事件是没有在 <code>this.$attrs</code> 和 <code>this.$listeners</code> 里面的</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/DA6B1A8E-7DC1-4a64-8E15-D58B7323E183.png" alt=""></p>
<blockquote>
<p>之后我们就可以直接使用 <code>v-bind=&quot;$attrs&quot;</code> 和 <code>v-on=&quot;$listeners&quot;</code> 把属性和事件继续传递下去，并且在子组件用 <code>props</code> 接收一下 <code>params2</code> 这个属性</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 第二级子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;嵌套组件传递过来的参数：&#123;&#123; <span class="variable">$attrs</span> &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'ChildCom2'</span>,</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    params2: &#123;</span><br><span class="line">      <span class="built_in">type</span>: String,</span><br><span class="line">      default: () =&gt; <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span></span>() &#123;</span><br><span class="line">    console.log(this.<span class="variable">$attrs</span>)</span><br><span class="line">    console.log(this.<span class="variable">$listeners</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/DDEEDE7C-392C-45d9-915F-986C0A755002.png" alt=""></p>
<blockquote>
<p>我们也同样可以在 <code>child-com-2</code> 组件看到，用 <code>props</code> 接收的属性和  <code>native</code> 修饰的事件是没有在 <code>this.$attrs</code> 和 <code>this.$listeners</code> 里面的</p>
</blockquote>
<div class="note info">
            <p>我觉得 <code>$attrs</code> 和 <code>$listeners</code> 属性像两个收纳箱，一个负责收纳属性，一个负责收纳事件，都是以对象的形式来保存数据。</p>
          </div>

<h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><div class="note info">
            <p>很多看官们肯定对这两个属性更加的陌生吧，让我们看来看看官方的解释。</p>
          </div>

<blockquote>
<p><code>provide</code> 和 <code>inject</code> 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。并且这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
</blockquote>
<blockquote>
<p>我们可以在根组件定义一下 <code>provide</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;son&gt;&lt;/son&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from <span class="string">'./components/com-4/Son'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Corresponded'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    params1: <span class="string">'javaScript'</span>,</span><br><span class="line">    params2: <span class="string">'html'</span>,</span><br><span class="line">    params3: <span class="string">'css'</span>,</span><br><span class="line">    params4: <span class="string">'vue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 嵌套组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; params1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  name: <span class="string">'Son'</span>,</span><br><span class="line">  inject: [<span class="string">'params1'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行上面代码之后，我们就可以发现，只有我们在子组件使用 <code>jnject</code> 注入了父组件 <code>provide</code> 提供的属性，就可以直接在页面使用了，不管是嵌套多少级组件。我们都可以通过 <code>jnject</code> 去拿到我们想要的父组件 <code>provide</code> 提供属性值。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>以上，就是我自己总结出来的一些组件之间的通信，除了以上这些还有其他办法可以进行组件通信，有兴趣的看官可以自行再去研究一下，我这里就不在多做阐述。本文章只是列出了自己觉得比较有用的组件通信方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
        <tag>通信</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>git-cz初使用</title>
    <url>/git-cz%E5%88%9D%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>在日常 git commit 中，就是你在做一次修改后类似于写一个备注，但是这样 commit 的文本若不进行管理，可读性不太好，所以为了规范化和可读性，推荐使用 git-cz 进行 commit 管理。</p>
</blockquote>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g git-cz</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>在我们 <code>git add .</code> 之后，按照正常的流程是直接 <code>git commit</code>，现在我们安装完 <code>git-cz</code> 之后，就需要使用以下命令来代替 <code>git commit</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cz</span><br></pre></td></tr></table></figure>

<h2 id="选择类型"><a href="#选择类型" class="headerlink" title="选择类型"></a>选择类型</h2><blockquote>
<p>执行完之后就会出现以下选择项，我们需要手动选择提交类型，type代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。所有的type类型如下：</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200326113900.png" alt=""></p>
<ul>
<li>test：测试用例，包括单元测试、集成测试等</li>
<li>feat：新增feature</li>
<li>fix: 修复bug</li>
<li>chore: 改变构建流程、或者增加依赖库、工具等</li>
<li>docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</li>
<li>refactor: 代码重构，没有加新功能或者修复bug</li>
<li>style: 仅仅修改了空格、格式缩进等等，不改变代码逻辑</li>
<li>perf: 优化相关，比如提升性能、体验</li>
<li>revert: 回滚到上一个版本</li>
</ul>
<blockquote>
<p>选择完提交类型之后，就可以根据提示一步步操作，最后执行 <code>git push</code> 就可以把提交代码到远程仓库上了。</p>
</blockquote>
<blockquote>
<p>最后就可以在仓库中看到规范化的 <code>commit</code> 记录了</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200326123920.png" alt=""></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git commit</tag>
        <tag>git 规范</tag>
        <tag>git 提交</tag>
      </tags>
  </entry>
  <entry>
    <title>vue如何实现路由权限控制</title>
    <url>/vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>在实际的开发过程中，我们通常会涉及到权限的问题，不同的用户进来只能看到他对应的菜单权限，页面上的菜单渲染是比较好实现的，这里就不多提，唯一比较难的就是路由的权限控制。</p>
</blockquote>
<a id="more"></a>

<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><blockquote>
<p>目前大概有两种思路可以实现路由的权限控制：</p>
</blockquote>
<ul>
<li>通过 <code>router.beforeEach()</code> 路由拦截的方式实现。</li>
<li>通过 <code>vue-router</code> 官方提供的  <code>addRoutes()</code> 来进行动态路由注入，注意 该方法只有 <code>vue-router</code> 的版本 <code>&gt;= 2.2</code> 才有效。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="路由拦截"><a href="#路由拦截" class="headerlink" title="路由拦截"></a>路由拦截</h3><blockquote>
<p>这种方式依赖于我们项目的路由表都是事先配置好的，假设我们的路由表有：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      redirect: <span class="string">'/index1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/index1'</span>,</span><br><span class="line">      name: <span class="string">'Index1'</span>,</span><br><span class="line">      component: Index1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/index2'</span>,</span><br><span class="line">      name: <span class="string">'Index2'</span>,</span><br><span class="line">      component: Index2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/index3'</span>,</span><br><span class="line">      name: <span class="string">'Index3'</span>,</span><br><span class="line">      component: Index3</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default router</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>router/index</code> 中，通过  <code>router.beforeEach()</code> 路由拦截去进行权限判断：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to: 从哪个路由来</span><br><span class="line">  // from: 去哪个路由</span><br><span class="line">  // next：是一个方法，使用路由拦截，必须在后面添加next()，否则路由无法跳转</span><br><span class="line"></span><br><span class="line">  // 假设我们从后台获取的权限为：</span><br><span class="line">  const list = [<span class="string">'index1'</span>, <span class="string">'index2'</span>]</span><br><span class="line"></span><br><span class="line">  // 如果没有匹配到，证明没有权限</span><br><span class="line">  <span class="keyword">if</span> (list.indexOf(to.name) === -1) &#123;</span><br><span class="line">    // next(<span class="string">'/login'</span>);</span><br><span class="line"></span><br><span class="line">    ... //或者执行其他操作</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //路由拦截可根据项目返回的权限自行调整，这里只是做了一个简单的例子</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>这种方式我个人是觉得比较low的。不是很推荐看官们使用，当然，如果是业务没那么复杂的，这种方式其实也够用了。</p>
          </div>

<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><blockquote>
<p>假设我们在登录的时候，后端返回的权限列表如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// leaf: 是我们用来判断是否唯一的</span><br><span class="line">// component：一般来说后端返回给我们的就是一个路径而已，所以我们需要自行的去加载组件</span><br><span class="line"><span class="built_in">export</span> const routers = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/main'</span>,</span><br><span class="line">    name: <span class="string">'main'</span>,</span><br><span class="line">    leaf: <span class="literal">false</span>,</span><br><span class="line">    component: <span class="string">'pages/main'</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/main/index1'</span>,</span><br><span class="line">        name: <span class="string">'index1'</span>,</span><br><span class="line">        component: <span class="string">'pages/index1'</span>,</span><br><span class="line">        leaf: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/main/index2'</span>,</span><br><span class="line">        name: <span class="string">'index2'</span>,</span><br><span class="line">        component: <span class="string">'pages/index2'</span>,</span><br><span class="line">        leaf: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/main/index3'</span>,</span><br><span class="line">        name: <span class="string">'index3'</span>,</span><br><span class="line">        component: <span class="string">'pages/index3'</span>,</span><br><span class="line">        leaf: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/main/index4'</span>,</span><br><span class="line">        name: <span class="string">'index4'</span>,</span><br><span class="line">        component: <span class="string">'pages/index4'</span>,</span><br><span class="line">        leaf: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'*'</span>,</span><br><span class="line">    component: <span class="string">'pages/noFind'</span>,</span><br><span class="line">    leaf: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>因为后端返回的 <code>component</code> 一般是个字符串，所以我们需要写个方法解析一下路径。</p>
          </div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param routers 初始数据，为数组格式，一般来说是个空数组</span><br><span class="line"> * @param data 后端返回的路由列表数据</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> generaMenu(routers, data) &#123;</span><br><span class="line">  data.forEach((item)=&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> menu = Object.assign(&#123;&#125;,item)</span><br><span class="line">    menu.component = import(`@/<span class="variable">$&#123;menu.component&#125;</span>.vue`)</span><br><span class="line">    <span class="keyword">if</span>(!item.leaf) &#123;</span><br><span class="line">      menu.children = []</span><br><span class="line">      generaMenu(menu.children,item.children)</span><br><span class="line">      menu.redirect = menu.children[0].path // 如果需要重定向的话，可以根据自己的需求进行选择</span><br><span class="line">    &#125;</span><br><span class="line">    routers.push(menu)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>注意：如果有用到404的路由话，需要把404这个路由放到整个路由表的最后一个，否则，因为一开始我们是没有对应的动态路由，默认就跳转到了404页面了，所以静态路由表不配置404路由，与动态路由一起注入到路由表中。</p>
          </div>

<blockquote>
<p>这样我们最终就得到了符合路由规则的路由表了。然后通过 <code>addRoutes()</code> 这个方法把路由给注入到路由表里面</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">this.<span class="variable">$route</span>.addRoutes(data)</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>注意：因为使用了 <code>addRoutes()</code> 这个方法之后，路由表已经可以认为是不可控的了，也就是说，已经注入的路由，没办法在通过官方给的api删除掉(当然，目前官方也没有提供相应的api)。那当我们A帐号退出之后，B帐号登录进来，也会执行 <code>addRoutes()</code> 这个方法，会一直累加上去，然后控制台上也会有警告，出现了重复的路由，然后我们访问A帐号有，B帐号没有的路由时，发现是可以进行访问的。这显然不符合我们的需求。</p>
          </div>

<blockquote>
<p>那么，我们该如何解决这个问题呢？</p>
</blockquote>
<ul>
<li>一种是在用户退出的时候，进行项目的重载：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location.href = <span class="string">'/'</span> //这种相对来说体验就非常差了，相当于重新刷新了页面，显然也是不符合我们的需求</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种就是重新初始化静态路由表： 首先，我们要对 <code>router/index</code> 进行改造一下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const createRouter = () =&gt; new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      redirect: <span class="string">'/login'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const router = createRouter()</span><br><span class="line"></span><br><span class="line">//重新实例化一个新的路由表，替换之前的路由表，然后将这个方法导出</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> <span class="function"><span class="title">resetRouter</span></span>() &#123;</span><br><span class="line">  const newRouter = createRouter()</span><br><span class="line">  router.matcher = newRouter.matcher // the relevant part</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后，我们在用户退出的时候，重新执行下 <code>resetRouter()</code> 这个方法就可以重新初始化静态路由表，同时也发现B账号进来之后，只能访问对应的路由权限而已。A账号的权限路由已经不存在了。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>以上就是我对路由权限的一点理解，如果看官们有更好的方案可以评论留言交流一下。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>router</tag>
        <tag>动态路由</tag>
        <tag>路由权限</tag>
      </tags>
  </entry>
  <entry>
    <title>git创建分支并提交远程分支的步骤</title>
    <url>/git%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E5%B9%B6%E6%8F%90%E4%BA%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<blockquote>
<p>在日常开发做，有的时候会涉及到多人协作开发，所以在这里记录一下在git多人协作开发下，如何在本地创建分支并提交远程分支</p>
</blockquote>
<a id="more"></a>

<div class="note info">
            <p>以下代码块中的 newbranch 均属于示例分支名，请根据实际情况自行修改</p>
          </div>

<h2 id="在本地创建分支"><a href="#在本地创建分支" class="headerlink" title="在本地创建分支"></a>在本地创建分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch newbranch</span><br></pre></td></tr></table></figure>

<h2 id="把本地分支push到远程"><a href="#把本地分支push到远程" class="headerlink" title="把本地分支push到远程"></a>把本地分支push到远程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin newbranch</span><br></pre></td></tr></table></figure>

<h2 id="切换到该分支"><a href="#切换到该分支" class="headerlink" title="切换到该分支"></a>切换到该分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout newbranch</span><br></pre></td></tr></table></figure>

<h2 id="查看本地修改"><a href="#查看本地修改" class="headerlink" title="查看本地修改"></a>查看本地修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h2 id="添加本地修改"><a href="#添加本地修改" class="headerlink" title="添加本地修改"></a>添加本地修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h2 id="commit修改"><a href="#commit修改" class="headerlink" title="commit修改"></a>commit修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'XXXX'</span></span><br></pre></td></tr></table></figure>

<h2 id="切换到主分支"><a href="#切换到主分支" class="headerlink" title="切换到主分支"></a>切换到主分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h2 id="更新远端代码"><a href="#更新远端代码" class="headerlink" title="更新远端代码"></a>更新远端代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="合并分支代码到主分支"><a href="#合并分支代码到主分支" class="headerlink" title="合并分支代码到主分支"></a>合并分支代码到主分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge newbranch</span><br></pre></td></tr></table></figure>

<h2 id="push到远程主分支"><a href="#push到远程主分支" class="headerlink" title="push到远程主分支"></a>push到远程主分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>


<div class="note info">
            <p>以上所示git命令需要看官们有一定git知识，本文只针对入门级看官，文章如有错误，请各位看官们批评指出，谢谢~</p>
          </div>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git分支</tag>
        <tag>git多人协作</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript数组去重</title>
    <url>/javaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<blockquote>
<p>在日常开发中，我们通常会用到数组去重的功能，所以在这里记录几种不需要借助第三方工具的数组去重方式。</p>
</blockquote>
<a id="more"></a>

<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote>
<p>利用 <code>indexOf</code> 来实现，如果 <code>indexOf (val) === -1</code> ，就 <code>push</code> 到新数组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> way1(arr) &#123;</span><br><span class="line">  var newArr = [] // 创建新数组</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(arr[i]) === -1) &#123; // 判断是否有这个值</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(newArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote>
<p>对数组进行排序，之后判断前后是否一致，不一致的话就 <code>push</code> 到新数组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> way2(arr) &#123;</span><br><span class="line">  var oldArr = arr.sort() // 对数组排序</span><br><span class="line">  var res = []</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; oldArr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldArr[i] !== res[res.length-1]) &#123;</span><br><span class="line">      res.push(oldArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><blockquote>
<p>利用 <code>ES6</code> 的 <code>set</code> 进行数组去重</p>
</blockquote>
<div class="note warning">
            <p><code>new set</code> 之后是一个集合，所以我们需要把他转为数组，可以使用 <code>es6</code> 的扩展运算符</p>
          </div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> way3(arr) &#123;</span><br><span class="line">  var old = new Set(arr)</span><br><span class="line">  var newArr = [...old]</span><br><span class="line">  console.log(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><blockquote>
<p>创建空的 数组 和 对象 ，将 数组值 当做 对象的键 判断对象上是否有键，没有的话就 <code>push</code> 到空数组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> way4(arr) &#123;</span><br><span class="line">  var res = []</span><br><span class="line">  var obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0;i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">      res.push(arr[i])</span><br><span class="line">      obj[arr[i]] = 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><blockquote>
<p>判断当前位置的元素首次出现的位置是不是在当前的位置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> way5(arr) &#123;</span><br><span class="line">  var res=[]</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.indexOf(arr[i]) === i) &#123;</span><br><span class="line">      res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h2><blockquote>
<p>两个 <code>for</code> 循环进行判断</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> way6(arr) &#123;</span><br><span class="line">  var res = []</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) j = ++i</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>以上几种数组去重方法，是我大概能想到的几种方法了，如果还有其他其实方式，会陆续进行更新。</p>
</blockquote>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实现图片上传到阿里云</title>
    <url>/vue%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/</url>
    <content><![CDATA[<blockquote>
<p>在项目中，有遇到图片上传到阿里云上，所以在这里分享记录下。</p>
</blockquote>
<a id="more"></a>

<div class="note info">
            <p>这里我们只提供一个简单的例子，请根据项目情况自行修改调整，这里我们使用了 <code>element</code> 的 <code>upload</code> 组件</p>
          </div>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>首先，我们需要安装一下 <code>ali-oss</code> 插件，然后在项目中引入</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install ali-oss --save</span><br><span class="line"></span><br><span class="line">import OSS from <span class="string">'ali-oss'</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>然后在 <code>template</code> 模版中使用 <code>upload</code> 组件，代码如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;el-upload</span><br><span class="line">    class=<span class="string">"avatar-uploader"</span></span><br><span class="line">    :show-file-list=<span class="string">"false"</span></span><br><span class="line">    :http-request=<span class="string">"avatarUpload"</span></span><br><span class="line">    accept=<span class="string">"image/png,image/gif,image/jpg,image/jpeg"</span></span><br><span class="line">    action=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img v-if=<span class="string">"imageUrl"</span> :src=<span class="string">"imageUrl"</span> class=<span class="string">"avatar"</span>&gt;</span><br><span class="line">    &lt;i v-else class=<span class="string">"el-icon-plus avatar-uploader-icon"</span>&gt;&lt;/i&gt;</span><br><span class="line">  &lt;/el-upload&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后使用 <code>upload</code> 组件中自定义上传方法 <code>http-request</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 自定义上传</span><br><span class="line">async avatarUpload(file) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!this.client) &#123;</span><br><span class="line">    this.client = new OSS(&#123;</span><br><span class="line">      region: <span class="string">'oss-cn-hangzhou'</span>,</span><br><span class="line">      accessKeyId: <span class="string">''</span>, // 阿里云的 AccessKey ID</span><br><span class="line">      accessKeySecret: <span class="string">''</span>, // 阿里云的 Access Key Secret</span><br><span class="line">      bucket: <span class="string">''</span> // 存储空间 Bucket 名称</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  const fileName = `<span class="variable">$&#123;file.file.name&#125;</span>` // 文件名称</span><br><span class="line">  const path = <span class="string">'/imgs/'</span> // 指定存放路径</span><br><span class="line">  try &#123;</span><br><span class="line">    const res = await this.client.multipartUpload(path + fileName, file.file)</span><br><span class="line">    <span class="keyword">if</span> (res.res) &#123;</span><br><span class="line">      // 上传成功之后的操作</span><br><span class="line">      this.imageUrl = res.res.requestUrls[0]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>accessKeyId、accessKeySecret、bucket 通常是由后端返回回来的，不推荐写死在前端代码中。</p>
          </div>

<blockquote>
<p>上传成功之后，我们就可以在阿里云上看到我们所上传的图片了</p>
</blockquote>
<p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/09ACC501-9978-4673-B5EC-AC2A5B28FCE7.png" alt=""></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>以上就是我对图片上传到阿里云的一点技术分享，目前多图上传的参考了网上的写法，基本上都是循环调用，我这里也暂时没找到相关的 API，所以如果看官们有多图上传的最优办法，欢迎留言评论。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>oss</tag>
        <tag>上传图片</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
</search>
