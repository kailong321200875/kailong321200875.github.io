<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小前端搬运工</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次就是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.chenkl.vip/"/>
  <updated>2021-03-04T10:34:49.647Z</updated>
  <id>https://www.chenkl.vip/</id>
  
  <author>
    <name>Archer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端有哪些异步</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%82%E6%AD%A5/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%82%E6%AD%A5/</id>
    <published>2021-03-04T14:32:44.000Z</published>
    <updated>2021-03-04T10:34:49.647Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>JavaScript</code>是单线程，不像<code>Java</code>等语言是多线程的，所以一般情况下，js代码是一行一行执行的，但是某些时候需要用异步来提升性能，比如说一个网络请求需要服务端返回数据30s，js不可能一直等待服务器返回再执行其他代码，这时候js就会跳过这个过程，继续往下执行，直到没有代码要执行了，这时候后端返回数据了，js再接着执行返回数据之后的代码。这个过程就是一个异步。</p><a id="more"></a><h2 id="异步说明"><a href="#异步说明" class="headerlink" title="异步说明"></a>异步说明</h2><p>如果你跟你女朋友不在一个班，但是你去找她的时候，发现她不在座位上，这时候你有2种选择，1.在座位上等她，然后啥都不干。2.你回到自己的座位上，继续抄作业，给她发消息等她回来，让她告诉你，你再去找她。第一种就是同步，第二种就是异步，实际上就是js的<code>事件委托</code>，很显然第二种方式效率更高。</p><h2 id="哪些情况会发生异步"><a href="#哪些情况会发生异步" class="headerlink" title="哪些情况会发生异步"></a>哪些情况会发生异步</h2><ol><li>回调函数，这个很常见，很多内置函数都支持接收回调函数来异步代码</li><li>事件监听，很多dom操作，click事件等都是异步的</li><li>订阅与发布，这个常见是在<code>angular</code>和<code>vue</code>中，用$on来监听事件，$emit来发布事件，经常用于父子组件交互</li><li><code>promise</code>是<code>ES6</code>新增的特性，能通过resolve和reject来执行异步操作</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道&lt;code&gt;JavaScript&lt;/code&gt;是单线程，不像&lt;code&gt;Java&lt;/code&gt;等语言是多线程的，所以一般情况下，js代码是一行一行执行的，但是某些时候需要用异步来提升性能，比如说一个网络请求需要服务端返回数据30s，js不可能一直等待服务器返回再执行其他代码，这时候js就会跳过这个过程，继续往下执行，直到没有代码要执行了，这时候后端返回数据了，js再接着执行返回数据之后的代码。这个过程就是一个异步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="异步" scheme="https://www.chenkl.vip/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://www.chenkl.vip/promise/"/>
    <id>https://www.chenkl.vip/promise/</id>
    <published>2021-03-03T10:22:44.000Z</published>
    <updated>2021-03-04T10:34:50.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Promise是ES6加入标准的一种异步编程解决方案，通常用来表示一个异步操作的最终完成(或失败)。Promise标准的提出，解决了javaScript地狱回调的问题。</p></blockquote><a id="more"></a><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>Promise</code>构造函数<code>executor</code>函数，<code>resolve</code>和<code>reject</code>两个函数作为参数传递给<code>executor</code>(executor函数在Promise构造函数返回所建promise实例前被调用)。<code>resolve</code>和<code>reject</code>函数被调用时，分别将<code>promise</code>的状态改为<code>fulfilled(完成)</code>或<code>rejected(失败)</code>。<code>executor</code>内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功或者失败)。如果在<code>executor</code>函数中抛出一个错误，那么该<code>promise</code>状态为<code>rejected</code>。<code>executor</code>函数的返回值将被忽略。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>Promise</code>对象在创建之后，并不一定会马上就有值，只是一个代理结果，它存在三种状态：</p><ol><li>pending：初始化状态（等待状态、挂起状态），既不是成功，也不是失败状态</li><li>fulfilled：意味着操作成功完成</li><li>rejected：意味着操作失败完成</li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><p>这个方法返回一个新的promise对象。一般该方法会接受一个<code>iterable</code>参数，里面是一个<code>promise</code>列表，当所有的promise都触发成功时才会触发成功，一旦有一个失败了，则会马上停止其他promise的执行。当iterable里面的结果都执行成功了，这个新的promise对象会将所有的结果已数组的形式依次返回。当有一个失败时，这个新的promise对象会将失败的信息返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建promise1，构造函数有2个参数resolve,reject</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我一开始就会执行！'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'itmeout 1'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'timeout 2'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1, p2, <span class="string">'p1, p2状态'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.all方法</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'all结果'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'此时：'</span>, p1, p2, <span class="string">'p1, p2状态'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720210303140509.png" alt=""></p><h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定相应句柄，并返回该promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建promise1，构造函数有2个参数resolve,reject</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我一开始就会执行！'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'itmeout 1'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'timeout 2'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1, p2, <span class="string">'p1, p2状态'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.race方法，任何一个成功或失败就会执行then方法</span></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'race结果'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'此时：'</span>, p1, p2, <span class="string">'p1, p2状态'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720210303142123.png" alt=""></p><h3 id="Promise-reject-rease"><a href="#Promise-reject-rease" class="headerlink" title="Promise.reject(rease)"></a>Promise.reject(rease)</h3><p>返回一个状态为失败的promise对象，并将给定的失败信息传递给对应的处理方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.reject方法测试</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'失败'</span>).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Promise.reject:'</span> + err))</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h3><p>返回一个状态由给定value决定的promise对象。如果该值是thenable（即，带有then方法的对象），返回的promise对象的最终状态由then方法执行决定；否则的话（该value为空，基本类型或者不带then方法的对象），返回的promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是promise对象，使用Promise.resolve(value)来返回一个promise对象，这样就能将该value以promise对象形式使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我一开始就会执行！'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'itmeout 1'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.resolve方法测试</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise.resolve的结果1：'</span> + res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(p1).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise.resolve的结果2：'</span> + res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Promise.resolve的结果1：1</span></span><br><span class="line"><span class="comment">// Promise.resolve的结果2：itmeout 1</span></span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>前端很常见是下面一个场景，我们需要实现一个用户修改头像的功能，首先我们需要将一张图片压缩并提交到后端，后端返回该图片保存的url，前端拿保存的url和用户id提交给服务器来修改用户头像。</p><ol><li>异步一：加载图片</li><li>异步二：压缩图片</li><li>异步三：上传图片</li><li>异步四：提交保存</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取头像、异步过程，成功之后执行回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readImg</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback &amp;&amp; callback(img)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩一张图片，压缩过程异步，成功之后执行回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compression</span>(<span class="params">img, callback</span>) </span>&#123;</span><br><span class="line">  zipImg(img, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传用户头像，异步请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadImg</span>(<span class="params">img, callback</span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/upload'</span>,</span><br><span class="line">    data: img,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">      callback &amp;&amp; callback(url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存最终数据，用户头像，异步请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/save'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      id,</span><br><span class="line">      url</span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      callback &amp;&amp; callback(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  readImg(<span class="function"><span class="keyword">function</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">    compression(img, <span class="function"><span class="keyword">function</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">      uploadImg(img, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">        saveData(url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的场景在我们开发过程中很常见，因为<code>javaScript</code>的异步特性，异步执行结果只能在回调函数里面才能拿到，所以就有了最终的<code>回调地狱</code>。这个过程异常极难排查，而且一层一层嵌套，代码极难维护也不美观。利用<code>promise链式调用</code>的特点，我们可以将上面的代码改成下面的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  readImg().then(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compression(img)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uploadImg(img)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> saveData(url)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="变量的方式创建"><a href="#变量的方式创建" class="headerlink" title="变量的方式创建"></a>变量的方式创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的方式创建</span></span><br><span class="line"><span class="keyword">const</span> myFisrstPromise = <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="comment">// 最终会执行resolve()或reject()</span></span><br><span class="line">&#125;)</span><br><span class="line">myFisrstPromise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 成功时候的操作</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 失败时候的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="函数的方式创建"><a href="#函数的方式创建" class="headerlink" title="函数的方式创建"></a>函数的方式创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFirstPromise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 最终会执行resolve()或reject()</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">myFisrstPromise().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 成功时候的操作</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 失败时候的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>Promise</code>是<code>ES6</code>加入标准的一种异步变成解决方案，通常用来表示一个异步操作的最终完成(或失败)。</li><li><code>Promise</code>链式调用的特点，解决了javaScript地狱回调的问题。</li><li><code>Promise</code>提供了一系列属性和方法。合理利用可以解决不少问题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Promise是ES6加入标准的一种异步编程解决方案，通常用来表示一个异步操作的最终完成(或失败)。Promise标准的提出，解决了javaScript地狱回调的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="promise" scheme="https://www.chenkl.vip/categories/promise/"/>
    
    
      <category term="promise" scheme="https://www.chenkl.vip/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>常见的9种设计模式</title>
    <link href="https://www.chenkl.vip/%E5%B8%B8%E8%A7%81%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.chenkl.vip/%E5%B8%B8%E8%A7%81%E7%9A%849%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-01T11:22:44.000Z</published>
    <updated>2021-03-04T10:34:50.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式是对软件开发过程中反复出现的某类问题的通用解决方法。设计模式更多的是指导思想和方法论，而不是现成的代码。当然每种设计模式都有每种语言中的具体实现方式。学习设计模式更多的是理解各种设计模式的思想和解决的问题。</p></blockquote><a id="more"></a><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><ol><li>结构型模式：通过识别系统中组件间的简单关系来简化系统的设计。</li><li>创建型模式：处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</li><li>行为型模式：用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。</li></ol><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><img src="https://pic3.zhimg.com/80/v2-7ca3af3e038c928ada59d6caad33836a_720w.jpg" alt=""></p><p><code>外观模式</code>是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。简而言之<code>外观设计模式</code>就是把多个子系统中复杂的逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都是遵循了<code>外观设计模式</code>，比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。其实在平时工作中我们也会经常用到<code>外观模式</code>进行开发，只是我们不自知而已。</p><p>比如，我们可以应用外观模式封装一个统一的DOM元素事件绑定/取消方法，用于兼容不同版本的浏览器和更方便的调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(event, handler, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">'on'</span> + event, handler)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span> + event] = handler</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">    element.removeEventListener(event, handler, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">    element.detachEvent(<span class="string">'on'</span> + event, handler)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span> + event] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><img src="https://pic4.zhimg.com/80/v2-05375788fe022386dc968c8d4bdf270f_720w.jpg" alt=""></p><p>首先，一切皆可代理，不管是在现实世界还是计算机世界。现实世界中买房有中介、打官司有律师、投资有经纪人，他们都是代理，由他们帮你处理由于你缺少时间或者专业技能而无法完成的事务。类比计算机领域，代理也是一样的作用，当访问一个对象本身的代价太高(比如太占内存、初始化时间太长等)或者需要增加额外的逻辑又不能修改对象本身时便可以使用代理。ES6中也增加了<code>Proxy</code>的功能。</p><p>代理模式可以解决以下的问题：</p><ol><li>增加对一个对象的访问控制</li><li>当访问一个对象的过程中需要增加额外的逻辑</li></ol><p>要实现代理模式需要三部分：</p><ol><li><code>Real Subject</code>：真实对象</li><li><code>Proxy</code>：代理对象</li><li><code>Subject</code>接口：Real Subject 和 Proxy 都需要实现的接口，这样 Proxy 才能被当成 Real Subject 的“替身”使用</li></ol><p>比如有一个股票价格查询接口，调用这个接口需要比较久的时间(用<code>setTimeout模拟2s的调用时间</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StockPriceAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Subject Interface 实现</span></span><br><span class="line">  <span class="keyword">this</span>.getValue = <span class="function"><span class="keyword">function</span>(<span class="params">stock, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Calling external API...'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (stock) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'GOOGL'</span>:</span><br><span class="line">          callback(<span class="string">'$1265.23'</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'AAPL'</span>:</span><br><span class="line">          callback(<span class="string">'$287.05'</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'MSFT'</span>:</span><br><span class="line">          callback(<span class="string">'$173.70'</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          callback(<span class="string">''</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不希望每次都去请求远程接口，而是增加缓存机制，当有缓存的时候就直接从缓存中获取，否则再去请求远程接口。我们可以通过一个<code>proxy</code>来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StockPriceAPIProxy</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StockPriceAPIProxy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存对象</span></span><br><span class="line">  <span class="keyword">this</span>.cache = &#123;&#125;</span><br><span class="line">  <span class="comment">// 真实API对象</span></span><br><span class="line">  <span class="keyword">this</span>.realAPI = <span class="keyword">new</span> StockPriceAPI()</span><br><span class="line">  <span class="comment">// Subject Interface 实现</span></span><br><span class="line">  <span class="keyword">this</span>.getValue = <span class="function"><span class="keyword">function</span>(<span class="params">stock, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cachedPrice = <span class="keyword">this</span>.cache[stock]</span><br><span class="line">    <span class="keyword">if</span> (cachedPrice) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Got price from cache'</span>)</span><br><span class="line">      callback(cachedPrice)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.realeAPI.getValue(stock, (price) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.cache[stock] = price</span><br><span class="line">        callback(price)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>Proxy</code>需要和真实对象一样实现 <code>getValue()</code> 方法，<code>getValue()</code> 就属于 <code>Subject接口</code></p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><img src="https://pic4.zhimg.com/80/v2-94d59dbbc541849d398ffe4532f3e0a3_720w.jpg" alt=""></p><p>现实生活中的工厂按照既定程序制造产品，随着生产原料和流程不同生产出来的产品也会有区别。应用到软件工程的领域，工程可以看成是一个制造其他对象的对象，制造出来的对象也会随着传入工厂对象参数的不同而有所不同。</p><p>什么场景适合应用工厂模式而不是直接用 <code>new</code> 一个对象呢？当构造函数过多不方便管理，且需要创建的对象之间存在某些关联（有同一个父类、实现同一个接口等）时，不妨使用工厂模式。工厂模式提供一种集中化、统一化的方式，避免了分散创建对象导致的代码重复、灵活性差的问题。</p><p>以上图为例，我们构造一个简单的汽车工厂来生产汽车：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuzukiCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'Suzuki'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HondaCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'Honda'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BMWCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'BMW'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车品牌枚举</span></span><br><span class="line"><span class="keyword">const</span> BRANDS = &#123;</span><br><span class="line">  Suzuki: <span class="number">1</span>,</span><br><span class="line">  Honda: <span class="number">2</span>,</span><br><span class="line">  bmw: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车工厂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">brand, color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (brand) &#123;</span><br><span class="line">      <span class="keyword">case</span> BRANDS.Suzuki:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuzukiCar(color)</span><br><span class="line">      <span class="keyword">case</span> BRANDS.honda:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HondaCar(color)</span><br><span class="line">      <span class="keyword">case</span> BRANDS.bmw:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMWCar(color)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用工厂模式之后，不再需要重复引入一个个构造函数，只需要引入工厂对象就可以方便的创建各类对象。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><img src="https://pic4.zhimg.com/80/v2-50bef18b2e069fa5611a680efd396a4b_720w.jpg" alt=""></p><p>顾名思义，单例模式中 <code>Class</code> 的实例个数最多为1，当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</p><p>实现单例模式需要解决以下几个问题：</p><ol><li>如何确定Class只有一个实例？</li><li>如何简便的访问Class的唯一实例？</li><li>Class如何控制实例化的过程？</li><li>如何将Class的实例个数限制为1？</li></ol><p>我们一般通过实现以下两点来解决上述问题：</p><ol><li>隐藏Class的构造函数，避免多次实例化</li><li>通过暴露一个 getInstance() 方法来创建/获取唯一实例</li></ol><p>javaScript中单例模式可以通过以下方式来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例构造器</span></span><br><span class="line"><span class="keyword">const</span> FooServiceSingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 隐藏的Class的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">FooService</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 未初始化的单例对象</span></span><br><span class="line">  <span class="keyword">let</span> fooService</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 创建/获取单例对象的函数</span></span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!fooService) &#123;</span><br><span class="line">        fooService = <span class="keyword">new</span> FooService()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fooService</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>实现的关键点有：</p><ol><li>使用 <code>IIFE</code> 创建局部作用域并即时执行</li><li><code>getInstance()</code> 为一个 <code>闭包</code>，使用闭包保存局部作用域中的单例对象并返回</li></ol><p>我们可以验证下单例对象是否创建成功：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooService1 = FooServiceSingleton.getInstance()</span><br><span class="line"><span class="keyword">const</span> fooService2 = FooServiceSingleton.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fooService1 === fooService2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><img src="https://pic1.zhimg.com/80/v2-7c20e73fdade6615874821f7e06f8ab4_720w.jpg" alt=""></p><p>策略模式化简单描述就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国教个人所得税”和“在中国交个人所得税”就有不同的算税方法。最常见的使用策略模式的常见如 <code>登录鉴权</code>，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后在动态的配置鉴权策略。所有这些策略应该实现统一的接口，或者说有统一的行为模式。Node生态里著名的鉴权库 <code>Passport.js</code> API的设计就应用了策略模式。</p><p>还是以登录鉴权的例子我们仿照 <code>Passport.js</code> 的思路通过代码来理解策略模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录控制器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginController</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.strategy = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.setStrategy = <span class="function"><span class="keyword">function</span>(<span class="params">strategy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy</span><br><span class="line">    <span class="keyword">this</span>.login = <span class="keyword">this</span>.strategy.login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户名、密码登录策略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LocalStragegy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; username, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(username, password)</span><br><span class="line">    <span class="comment">// authenticating with username and password... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机号、验证码登录策略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneStragety</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; phone, verifyCode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(phone, verifgCode)</span><br><span class="line">    <span class="comment">// authenticating with hone and verifyCode... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方社交登录策略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SocialStragety</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; id, secret &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, secret)</span><br><span class="line">    <span class="comment">// authenticating with id and secret... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loginController = <span class="keyword">new</span> LoginController()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用用户名、密码登录接口，使用LocalStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/local'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> LocalStragegy())</span><br><span class="line">  loginController.login(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用手机、验证码登录接口，使用PhoneStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/phone'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> PhoneStragety())</span><br><span class="line">  loginController.login(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用社交登录接口，使用SocialStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/social'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> SocialStragety())</span><br><span class="line">  loginController.login(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从以上示例可以得出使用策略模式有以下优势：</p><ol><li>方便在运行时切换算法和策略</li><li>代码更简洁，避免使用大量的条件判断</li><li>关注分离，每个strategy类控制自己的算法逻辑，strategy和其使用者之间也相互独立</li></ol><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><img src="https://pic2.zhimg.com/80/v2-83b7c4f76fa28844546dfb760f00be19_720w.jpg" alt=""></p><p><code>ES6</code>中的迭代器<code>Iterator</code>相信大家都不陌生，迭代器用于遍历容器(集合)并访问容器中的元素，而且无论容器的数据结构是什么(Array、Set、Map)等，迭代器的接口都应该是一样的。都需要遵循迭代器协议。</p><p>迭代器模式解决了以下问题：</p><ol><li>提供一致的遍历各种数据结构的方式，而不用了叫数据的内部结构</li><li>提供遍历容器(集合)的能力而无需改变容器的接口</li></ol><p>一个迭代器通常需要实现以下接口：</p><ol><li><code>hasNext()</code>：判断迭代是否结束，返回Boolean</li><li><code>next()</code>：查找并返回下一个元素</li></ol><p>为javaScript的数据实现一个迭代器可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> item = [<span class="number">1</span>, <span class="string">'red'</span>, <span class="literal">false</span>, <span class="number">3.14</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Iterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.items = items</span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator.prototype = &#123;</span><br><span class="line">  hasNext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;,</span><br><span class="line">  next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.index++]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证下迭代器是否工作</span></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="keyword">new</span> Iterator(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iterator.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ES6</code>提供了更简单的迭代循环语法 <code>for...of</code>，使用该语法的前提是操作对象需要实现可迭代协议，简单说就是该对象有个Key为<code>Symbol.iterator</code>的方法，该方法返回一个iterator对象。</p><p>比如我们实现一个<code>Range</code>类用于在某个数字区间进行迭代：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              value: start ++,</span><br><span class="line">              done： <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              done: <span class="literal">true</span>,</span><br><span class="line">              value: end</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证一下</span></span><br><span class="line"><span class="keyword">for</span> (num <span class="keyword">of</span> Range(<span class="number">1</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><img src="https://pic2.zhimg.com/80/v2-b30b0a7a7fb8560f151b246002154f9d_720w.jpg" alt=""></p><p>观察者模式又称发布订阅模式，是我们经常接触到的设计模式，日常生活中的应用也比比皆是，比如你订阅了某个博主的频道，当有内容更新时会收到推送。又比如javaScript中的事件订阅响应机制。观察者模式的思想用一句话描述就是：<code>被观察对象(subject)维护一组观察者(observer)，当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。</code></p><p>比如给DOM元素绑定事件的<code>addEventListener()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener [, options])</span><br></pre></td></tr></table></figure><p>Target就是被观察对象Subject，listener就是观察者Observer。</p><p>观察者模式中Subject对象一般需要实现以下API：</p><ol><li><code>subscribe()</code>：接收一个观察者observer对象，使其订阅自己</li><li><code>unsubscribe()</code>：接收一个观察者observer对象，使其取消订阅自己</li><li><code>fire()</code>：触发事件，通知到所有观察者</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observers = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  subscribe: <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  unsubscribe: <span class="function"><span class="keyword">function</span>(<span class="params">observerToRemove</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">this</span>.observers.filter(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> observer !== observerToRemove</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.call()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证是否成功</span></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Observer 1 firing!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Observer 2 firing!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observer1)</span><br><span class="line">subject.subscribe(observer2)</span><br><span class="line">subject.fire()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Observer 1 Firing! </span></span><br><span class="line"><span class="comment">// Observer 2 Firing!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证一下取消订阅是否成功</span></span><br><span class="line">subject.unsubscribe(observer2)</span><br><span class="line">subject.fire()</span><br></pre></td></tr></table></figure><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><img src="https://pic3.zhimg.com/80/v2-a4ec4deb78373a1c936a64e65ec77052_720w.jpg" alt=""></p><p>在中介者模式中，中介者包装了一些列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。</p><p>中介者模式和观察者模式有一定的相似性，都是一对多的关系，也都是集中式通信，不同的是中介者模式是处理同级对象之间的交互，而观察者模式是处理Observer和subject之间的交互。中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。中介者模式比较常见的应用比如聊天室，聊天室里面的人之间并不能直接对话，而是通过聊天室这一媒介进行转发。一个简易的聊天室模型可以实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聊天室成员类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Member</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.chatroom = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">Member.prototype = &#123;</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  send: <span class="function"><span class="keyword">function</span>(<span class="params">message, toMember</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.chatroom.send(message, <span class="keyword">this</span>, toMember)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接收消息</span></span><br><span class="line">  receive: <span class="function"><span class="keyword">function</span>(<span class="params">message, fromMember</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;fromMember.name&#125;</span> to <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聊天室类：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chatroom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.members = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Chatroom.prototype = &#123;</span><br><span class="line">  <span class="comment">// 增加成员</span></span><br><span class="line">  addMember: <span class="function"><span class="keyword">function</span>(<span class="params">member</span>) </span>&#123;</span><br><span class="line">    member.chatroom = <span class="keyword">this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 发送消息</span></span><br><span class="line">  send: <span class="function"><span class="keyword">function</span>(<span class="params">message, fromMember, toMember</span>) </span>&#123;</span><br><span class="line">    toMember.receive(message, fromMember)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">const</span> chatroom = <span class="keyword">new</span> Chatroom()</span><br><span class="line"><span class="keyword">const</span> bruce = <span class="keyword">new</span> Member(<span class="string">'bruce'</span>)</span><br><span class="line"><span class="keyword">const</span> frank = <span class="keyword">new</span> Member(<span class="string">'frank'</span>)</span><br><span class="line"></span><br><span class="line">chatroom.addMember(bruce)</span><br><span class="line">chatroom.addMember(frank)</span><br><span class="line"></span><br><span class="line">bruce.send(<span class="string">'Hey frank'</span>, frank)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// bruce to frank: hello frank</span></span><br></pre></td></tr></table></figure><p>这是一个最简单的聊天室模型，真正的聊天室还可以加入更多的功能，比如敏感信息拦截、一对多聊天、广播等。得益于中介模式，Member不需要处理和聊天相关的复杂逻辑，而是全部交给Chatroom，有效的实现了关注分离。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p><img src="https://pic2.zhimg.com/80/v2-2656b6d0e848450ce4d9e216715f1fed_720w.jpg" alt=""></p><p>访问者模式是一种将算法与对象结构分离的设计模式，通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用语拓展一些第三方的库和工具。</p><p>访问者模式的实现有以下几个要素：</p><ol><li><code>Visitor Object</code>：访问者对象，拥有一个<code>visit()</code>方法</li><li><code>Receiving Object</code>： 接收对象，拥有一个 <code>accept()</code>方法</li><li><code>visit(receivingObjec)</code>：用于Visitor接收一个Receiving Object</li><li><code>accept(visitor)</code>：用于Receving Object接收一个Visitor，并通过调用Visitor的<code>visit()</code>为其提供获取Receiving Object数据的能力</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Receiving Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.salary = salary</span><br><span class="line">&#125;</span><br><span class="line">Employee.prototype = &#123;</span><br><span class="line">  getSalary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.salary</span><br><span class="line">  &#125;,</span><br><span class="line">  setSalary: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary</span><br><span class="line">  &#125;,</span><br><span class="line">  accept: <span class="function"><span class="keyword">function</span>(<span class="params">visitor</span>) </span>&#123;</span><br><span class="line">    visitor.visit(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visitor Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Visitor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Visitor.prototype = &#123;</span><br><span class="line">  visit: <span class="function"><span class="keyword">function</span>(<span class="params">employee</span>) </span>&#123;</span><br><span class="line">    employee.setSalary(employee.getSalary() * <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证一下</span></span><br><span class="line"><span class="keyword">const</span> employee = <span class="keyword">new</span> Employee(<span class="string">'bruce'</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">const</span> visitor = <span class="keyword">new</span> Visitor()</span><br><span class="line"></span><br><span class="line">employee.accept(visitor)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(employee.getSalary()) <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式是对软件开发过程中反复出现的某类问题的通用解决方法。设计模式更多的是指导思想和方法论，而不是现成的代码。当然每种设计模式都有每种语言中的具体实现方式。学习设计模式更多的是理解各种设计模式的思想和解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="设计模式" scheme="https://www.chenkl.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(十三)--深入核心，详解事件循环机制</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%B8%89)--%E6%B7%B1%E5%85%A5%E6%A0%B8%E5%BF%83%EF%BC%8C%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%B8%89)--%E6%B7%B1%E5%85%A5%E6%A0%B8%E5%BF%83%EF%BC%8C%E8%AF%A6%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-08-22T16:16:39.000Z</published>
    <updated>2020-08-23T01:53:40.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript的学习零散而庞杂，事件循环机制(Event Loop)则是最关键的知识点。</p></blockquote><a id="more"></a><blockquote><p>事件循环机制从整体上告诉了我们JavaScript代码的执行顺序。在面试中，事件循环机制总是绕不开的话题。特别是ES6中正式加入了promise对象之后，对于新标准中事件循环机制的理解就变得更加重要。</p></blockquote><blockquote><p>在学习事件循环机制之前，我们默认懂得了如下概念：</p></blockquote><ul><li>执行上下文(Execution context)</li><li>函数调用栈(call stack)</li><li>队列数据结构(queue)</li><li>Promise</li></ul><div class="note info">            <p>因此chrome浏览器中新标准中的事件循环机制与nodejs类似，因此此处整合nodejs一起理解，其中会介绍到几个nodejs有，但是浏览器中没有的API，我们只需要了解就好，不一定非要知道它是如何使用。比如process.nextTick，setImmediate</p>          </div><blockquote><p>我们都知道JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。</p></blockquote><blockquote><p>JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外的一些代码的执行。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200708105534.png" alt=""></p><ul><li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</li><li>任务队列又分为macro-task(宏任务)与micro-task(微任务)，在最新标准中，它们被分别称为task与jobs。</li><li>macro-task大概包括：script(整体代码)，setTimeout，setInterval，setImmediate，I/O，UI，rendering。</li><li>micro-task大概包括：process.nextTick，promise，Object.observe(已废弃)，MutationObserver(html5新特性)。</li><li>setTimeout/Promise等我们称之为任务源，而进入任务队列的是他们指定的具体执行任务。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// setTimeout中的回调函数才是进入任务队列的任务</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'xxxx'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">// 非常多的人对于setTimeout的理解存在偏差，所以大概说一下误解：</span><br><span class="line">// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要奋发的任务，也就是它的第一个参数，才是延迟执行</span><br></pre></td></tr></table></figure><ul><li>来自不同任务源的任务会进入到不同的任务队列，其中setTimeout与setInterval是同源的。</li><li>事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务对垒执行完毕，然后在执行所有的micro-task，这样一直循环下去。</li><li>其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。纯文字表述有点干涩，因此，我们通过2个例子，来逐步理解事件循环的具体顺序。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line">// 为了方便理解，我们以打印出来的字符作为当前的任务名称</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'timeout1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">  console.log(<span class="string">'promise1'</span>)</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; 1000; i ++) &#123;</span><br><span class="line">    i == 99 &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'then1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'global1'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>首先，事件循环从宏任务队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务。每一个任务的执行顺序，都依靠函数调用栈来搞定，而当遇到任务源时，则会先分发任务到对应的队列中去，所以，上面例子的第一步执行如下如所示。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822164407.png" alt=""></p><blockquote><p>第二步：script任务执行时首先遇到了setTimeout，setTimeout为一个宏任务源，那么他的作用就是讲任务分发到它对应的队列中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'timeout1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822164659.png" alt=""></p><blockquote><p>第三步：script执行时遇到Promise实例。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行，而后续的.then则会被分发到micro-task的Promise队列中去。</p></blockquote><blockquote><p>因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行，所以这里的Promise1和Promise2会依次输出。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822165043.png" alt="promise1入栈执行，这时promise1被最先输出"></p><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822165137.png" alt="resolve在for循环中入栈执行"></p><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822165219.png" alt="构造函数执行完毕的过程中，resolve执行完毕出栈，promise2输出，promise1页出栈，then执行时，Promise任务then1进入对应队列"></p><blockquote><p>script任务继续往下执行，最后只有一句输出了global，然后，全局任务就执行完毕了。</p></blockquote><blockquote><p>第四步：第一个宏任务script执行完毕之后，就开始执行所有的可以执行的微任务。这个时候，微任务中，只有Promise队列中的一个任务then1，因此直接执行就行了，执行结果输出then1，当然，它的执行，也是进入函数调用栈中执行的。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822165539.png" alt="执行所有的微任务"></p><blockquote><p>第五步：当所有的micro-task执行完毕之后，表示第一轮的循环就结束了。这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务macro-task开始。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822165730.png" alt="微任务被清空"></p><blockquote><p>这个时候，我们发现宏任务中，只有在setTimout队列中还要一个timeout1的任务等待执行。因此就直接执行即可。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822165845.png" alt="timeout1入栈执行"></p><blockquote><p>这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。</p></blockquote><blockquote><p>那么上面这个例子的输出结果就显而易见了。</p></blockquote><blockquote><p>这个例子比较简单，涉及到的队列任务并不多，因此读懂了它还不能全面的了解到事件循环机制的全貌。下面弄了一个复杂点的例子。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// demo02</span><br><span class="line">console.log(<span class="string">'golb1'</span>)</span><br><span class="line"></span><br><span class="line">setTimout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'timeout1'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout1_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'timeout1_promise'</span>)</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout1_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'immediate1'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'immediate_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'immediate_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log*(<span class="string">'immediate_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob1_nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">  console.log(<span class="string">'glob1_promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob1_then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'timeout2'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout2_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'timeout2_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout2_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob2_nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">  console.log(<span class="string">'glob2_promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob2_then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'immediate2'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'immediate2_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'immediate2_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'immediate2_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>第一步：宏任务script首先执行。全局入栈。glob1输出。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822171744.png" alt="script首先执行"></p><blockquote><p>第二步，执行过程遇到setTimeout。setTimeout作为任务分发器，将任务分发到对应的宏任务队列中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'timeout1'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout1_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'timeout1_promise'</span>)</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout1_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822171900.png" alt="timeout1进入对应队列"></p><blockquote><p>第三步：执行过程遇到setImmediate。setImmediate也是一个宏任务分发器，将任务分发到对应的任务队列中。setImmediate的任务队列会在setTimeout队列的后面执行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'immediate1'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'immediate_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'immediate_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log*(<span class="string">'immediate_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822172007.png" alt="进入setImmediate队列"></p><blockquote><p>第四步：执行遇到nextTick，process.nextTick是一个微任务分发器，它会将任务分发到对应的微任务队列中去。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob1_nextTick'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822172106.png" alt="nextTick"></p><blockquote><p>第五步：执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。因此，glob1_promise会第二个输出。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">  console.log(<span class="string">'glob1_promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob1_then'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822172625.png" alt="先是函数调用栈的变化"></p><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822172818.png" alt="然后glob1_then任务进入队列"></p><blockquote><p>第六步：执行遇到第二个setTimeout。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'timeout2'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout2_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'timeout2_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'timeout2_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822173013.png" alt="timeout2进入对应队列"></p><blockquote><p>第七步：先后遇到nextTick与Promise</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob2_nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">  console.log(<span class="string">'glob2_promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'glob2_then'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822173336.png" alt="glob2_nextTick与Promise任务分别进入各自的队列"></p><blockquote><p>第八步：再次遇到setImmediate。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'immediate2'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'immediate2_nextTick'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">    console.log(<span class="string">'immediate2_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'immediate2_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822173439.png" alt="nextTick"></p><blockquote><p>这个时候，script中的代码就执行完毕了，执行过程中，遇到不同的任务分发器，就将任务分发到各自对应的队列中去。接下来，将会执行所有的微任务队列中的任务。</p></blockquote><blockquote><p>其中，nextTick队列会比Promie先执行。nextTick中的可执行任务执行完毕之后，才会开始执行Promise队列中的任务。</p></blockquote><blockquote><p>当所有可执行的微任务执行完毕之后，这一轮循环就表示结束了。下一轮循环继续从宏任务队列开始执行。</p></blockquote><blockquote><p>这个时候，script已经执行完毕，所以就从setTimeout队列开始执行。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822173549.png" alt="第二轮循环初始状态"></p><blockquote><p>setTimeout任务的执行，也依然是借助函数调用栈来完成，并且遇到任务分发器的时候也会将任务分发到对应的队列中去。</p></blockquote><blockquote><p>只有当setTimeout中所有的任务执行完毕之后，才会再次开始执行微任务队列。并且清空所有的可执行微任务。</p></blockquote><blockquote><p>setTiemout队列产生的微任务执行完毕之后，循环则回过头来开始执行setImmediate队列。仍然是先将setImmediate队列中的任务执行完毕，再执行所产生的微任务。</p></blockquote><blockquote><p>当setImmediate队列执行产生的微任务全部执行之后，第二轮循环也就结束了。</p></blockquote><blockquote><p>当然，这些顺序都是v8的一些实现。我们也可以根据上面的规则，来尝试实现一下事件循环的机制。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 用数组模拟一个队列</span><br><span class="line">var tasks = []</span><br><span class="line"></span><br><span class="line">// 模拟一个事件分发器</span><br><span class="line">var addFn1 = <span class="keyword">function</span>(task) &#123;</span><br><span class="line">  tasks.push(task)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行所有的任务</span><br><span class="line">var flush = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  tasks.map(<span class="keyword">function</span>(task) &#123;</span><br><span class="line">    task()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后利用setTimeout/或者其他你认为合适的方式丢入事件循环中</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  flush()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 当然，也可以不用丢进事件循环，而是我们自己手动在适当的时机去执行对应的某一个方法</span><br><span class="line"></span><br><span class="line">var dispatch = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">  tasks.map(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">    <span class="keyword">if</span>(item.name == name) &#123;</span><br><span class="line">      item.handler()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当然，我们把任务丢进去的时候，多保存一个name即可。</span><br><span class="line">// 这时候，task的格式就如下</span><br><span class="line">demoTask =  &#123;</span><br><span class="line">  name: <span class="string">'demo'</span>,</span><br><span class="line">  handler: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 于是，一个订阅-通知的设计模式就这样轻松的被实现了</span><br></pre></td></tr></table></figure><blockquote><p>这样，我们就模拟了一个任务队列。我们还可以定义另外一个队列，利用上面的各种方式来规定他们的优先级。</p></blockquote><div class="note warning">            <p>需要注意的是，这里的执行顺序，或者执行的优先级在不同的场景里由于实现的不同会导致不同的结果，包括node的不同版本，不同浏览器等都有不同的结果。</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript的学习零散而庞杂，事件循环机制(Event Loop)则是最关键的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="事件循环" scheme="https://www.chenkl.vip/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(十二)--详细图解jQuery对象，以及如何扩展jQuery插件</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%BA%8C)--%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3jQuery%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95jQuery%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%BA%8C)--%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3jQuery%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95jQuery%E6%8F%92%E4%BB%B6/</id>
    <published>2020-08-22T09:52:14.000Z</published>
    <updated>2020-08-23T01:53:06.850Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着前端的迅猛发展，另外几种前端框架的崛起，jQuery慢慢变得不再是必须。但是我认为，项目中可以不用，但是仍然建议学。</p></blockquote><a id="more"></a><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><blockquote><p>使用jQuery对象时，我们这样写：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个jQuery对象</span><br><span class="line">$(<span class="string">'.target'</span>)</span><br><span class="line"></span><br><span class="line">// 获取元素的css属性</span><br><span class="line">$(<span class="string">'.target'</span>).css(<span class="string">'width'</span>)</span><br><span class="line"></span><br><span class="line">// 获取元素的位置信息</span><br><span class="line">$(<span class="string">'.target'</span>).offset()</span><br></pre></td></tr></table></figure><blockquote><p>在最开始，我们会有许多疑问，比如$是怎么回事？为什么不用new就可以直接声明一个对象？</p></blockquote><blockquote><p>我们直代码来展示并解释</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(<span class="keyword">function</span> (ROOT) &#123;</span><br><span class="line"></span><br><span class="line">  // 构造函数</span><br><span class="line">  var jQuery = <span class="keyword">function</span> (selector) &#123;</span><br><span class="line"></span><br><span class="line">    // 在jQuery中直接返回new过的实例，这里的init是jQuery的真正构造函数</span><br><span class="line">    <span class="built_in">return</span> new jQuery.fn.init(selector)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    constructor: jQuery,</span><br><span class="line"></span><br><span class="line">    version: <span class="string">'1.0.0'</span>,</span><br><span class="line"></span><br><span class="line">    init: <span class="keyword">function</span> (selector) &#123;</span><br><span class="line">      // 在jquery中这里有一个复杂的判断，但是这里我做了简化</span><br><span class="line">      var elem, selector;</span><br><span class="line">      elem = document.querySelector(selector);</span><br><span class="line">      this[0] = elem;</span><br><span class="line"></span><br><span class="line">      // 在jquery中返回一个由所有原型属性方法组成的数组，我们这里简化，直接返回this即可</span><br><span class="line">      // <span class="built_in">return</span> jQuery.makeArray(selector, this);</span><br><span class="line">      <span class="built_in">return</span> this;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 在原型上添加一堆方法</span><br><span class="line">    toArray: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    get: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    each: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    ready: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    first: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    slice: <span class="function"><span class="title">function</span></span> () &#123; &#125;</span><br><span class="line">    // ... ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">  // 实现jQuery的两种扩展方式</span><br><span class="line">  jQuery.extend = jQuery.fn.extend = <span class="keyword">function</span> (options) &#123;</span><br><span class="line"></span><br><span class="line">    // 在jquery源码中会根据参数不同进行很多判断，我们这里就直接走一种方式，所以就不用判断了</span><br><span class="line">    var target = this;</span><br><span class="line">    var copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">      copy = options[name];</span><br><span class="line">      target[name] = copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // jQuery中利用上面实现的扩展机制，添加了许多方法，其中</span><br><span class="line"></span><br><span class="line">  // 直接添加在构造函数上，被称为工具方法</span><br><span class="line">  jQuery.extend(&#123;</span><br><span class="line">    isFunction: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    <span class="built_in">type</span>: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    parseHTML: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    parseJSON: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    ajax: <span class="function"><span class="title">function</span></span> () &#123; &#125;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 添加到原型上</span><br><span class="line">  jQuery.fn.extend(&#123;</span><br><span class="line">    queue: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    promise: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    attr: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    prop: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    addClass: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    removeClass: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    val: <span class="function"><span class="title">function</span></span> () &#123; &#125;,</span><br><span class="line">    css: <span class="function"><span class="title">function</span></span> () &#123; &#125;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // $符号的由来，实际上它就是jQuery，一个简化的写法，在这里我们还可以替换成其他可用字符</span><br><span class="line">  ROOT.jQuery = ROOT.$ = jQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><blockquote><p>在上面代码中，我们封装了一个简化版的jQuery对象，它向我们简单展示了jQuery的整体骨架。</p></blockquote><blockquote><p>在代码中可以看到，jQuery自身对于原型的处理使用了一些巧妙的方式，比如<code>jQuery.fn = jQuery.prototype</code>,<code>jQuery.fn.init.prototype = jQuery.fn</code>等，这几句正是jQuery对象的关键所在。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822100702.png" alt=""></p><h2 id="对象封装分析"><a href="#对象封装分析" class="headerlink" title="对象封装分析"></a>对象封装分析</h2><blockquote><p>在上面的实现中，首先在jQuery构造函数里声明了一个fn属性，并将其指向了原型<code>jQuery.prototype</code>。然后在原型中添加了init方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuyer.fn = jQuery.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之后又将init的原型，指向了jQuery.prototype</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.init.prototype = jQuery.fn</span><br></pre></td></tr></table></figure><blockquote><p>而在构造函数jQuery，返回了init的实例对象</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = <span class="keyword">function</span>(selector) &#123;</span><br><span class="line">  // 在jQuery中直接返回new过的实例，这里的init是jQuery的真正构造函数</span><br><span class="line">  <span class="built_in">return</span> new jQuery.fn.init(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后对外暴露入口时，将字符<code>$</code>与<code>jQuery</code>对等起来</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROOT.jQuery = ROOT.$ = jQuery</span><br></pre></td></tr></table></figure><blockquote><p>因此当我们直接使用<code>$(&#39;#test&#39;)</code>创建一个对象时，实际上是创建了一个init的实例，这里的真正构造函数时原型中的init方法。</p></blockquote><div class="note warning">            <p>许多对jQuery内部实现不太了解的人，常常会毫无节制使用<code>$()</code>，比如对于同一个元素的不同操作。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var width = parseInt($(<span class="string">'#test'</span>).css(<span class="string">'width'</span>))</span><br><span class="line"><span class="keyword">if</span> (width &gt; 20) &#123;</span><br><span class="line">  $(<span class="string">'#test'</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'red'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过我们上面的分析，我们知道当我们执行<code>$()</code>时，就会重新生成一个init实例对象，因此当我们这样没有节制的使用jQuery是非常不正确的，虽然看上去方便一些，但是对于内存的消耗非常大。正确的做法是既然是同一个对象，那么就用一个变量保存起来后续使用即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="variable">$test</span> = $(<span class="string">'#test'</span>)</span><br><span class="line">var width = parseInt(<span class="variable">$test</span>.css(<span class="string">'width'</span>))</span><br><span class="line"><span class="keyword">if</span> (width &gt; 20) &#123;</span><br><span class="line">  <span class="variable">$test</span>.css(<span class="string">'backgroundColor'</span>, <span class="string">'red'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展方法分析"><a href="#扩展方法分析" class="headerlink" title="扩展方法分析"></a>扩展方法分析</h2><blockquote><p>在上面的代码中，我们还简单实现了两个扩展方法</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = <span class="keyword">function</span> (options) &#123;</span><br><span class="line"></span><br><span class="line">  // 在jquery源码中会根据参数不同进行很多判断，我们这里就直接走一种方式，所以就不用判断了</span><br><span class="line">  var target = this;</span><br><span class="line">  var copy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">    copy = options[name];</span><br><span class="line">    target[name] = copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要理解它的实现，首先要明确知道this指向。</p></blockquote><blockquote><p>传入的参数options为一个<code>key: value</code>模式的对象，我们通过<code>for in</code>遍历options，将key作为jQuery的新属性，value作为该新属性所对应的新方法，分别添加到jQuery方法和jQuery.fn中。</p></blockquote><blockquote><p>也就是说，当我们通过<code>jQuery.extend</code>扩展jQuery时，方法被添加到了jQuery构造函数中，而当我们通过<code>jQuery.fn.extend扩展jQuery</code>时，方法被添加到了jQuery原型中。</p></blockquote><h2 id="被静态方法，工具方法和实例方法"><a href="#被静态方法，工具方法和实例方法" class="headerlink" title="被静态方法，工具方法和实例方法"></a>被静态方法，工具方法和实例方法</h2><blockquote><p>关于封装一个对象。我们之前提到过，在封装对象时，属性和方法可以具体放置的三个位置，并且对于这三个位置的不同做了一个详细的解读。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200822102844.png" alt=""></p><blockquote><p>在实现jQuery扩展方法时，一部分方法需要扩展到构造函数中，一部分方法需要扩展到原型中，当我们通读jQuery源码时，还发现有一些方法在了模块作用域中。</p></blockquote><blockquote><p>这里用一个例子简单区分一下。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 模块内部</span><br><span class="line">const a = 20</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  // 构造函数方法，每声明一个实例，都会重新创建一次，属于实例独有</span><br><span class="line">  this.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原型方法，仅在原型创建时声明一次，属于所有实例共享</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工具方法，直接挂载在构造函数名上，仅声明一次，无法直接访问实例内部属性与方法</span><br><span class="line">Person.each = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上，each就是一个工具方法，或者说静态方法。</p></blockquote><blockquote><p>工具方法的特性也和工具一词非常贴近，他们与实例的自身属性毫无关联，仅仅只是实现一些通用的功能，我们可以通过<code>$.each</code>与<code>$(&#39;div&#39;).each</code>这2个方法来体会工具方法与实例方法的不同之处。</p></blockquote><blockquote><p>在实际开发中，我们运用到非常多的一个工具库就是<code>lodash.js</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax()</span><br><span class="line">$.isFunction()</span><br><span class="line">$.each()</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><blockquote><p>放在原型中的方法，在使用时必须创建一个新的实例对象才能访问，因此这样的方法叫做实例方法。也正因为这一点，他的使用成本会比工具方法高一些。但是相比构造函数方法，原型方法更节省内存。</p></blockquote><blockquote><p>所以通过<code>$.extend</code>扩展的方法，其实就是对工具方法的扩展，而通过<code>$.fn.extend</code>扩展的方法，就是对于实例方法的扩展。</p></blockquote><h2 id="jQuery插件的实现"><a href="#jQuery插件的实现" class="headerlink" title="jQuery插件的实现"></a>jQuery插件的实现</h2><blockquote><p>具体也没有什么可以多说的了，大家看了代码就可以明白一切。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">      <span class="comment">#target,</span></span><br><span class="line">      <span class="comment">#target2 &#123;</span></span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        background-color: orange;</span><br><span class="line">        cursor: move;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">#target2 &#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"target"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"target2"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script src=<span class="string">"http://libs.baidu.com/jquery/2.1.4/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    ;</span><br><span class="line">    (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      // 这是一个私有属性，不需要被实例访问</span><br><span class="line">      var transform = getTransform();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> Drag(selector) &#123;</span><br><span class="line">        // 放在构造函数中的属性，都是属于每一个实例单独拥有</span><br><span class="line">        this.elem = typeof selector == <span class="string">'Object'</span> ? selector : document.getElementById(selector);</span><br><span class="line">        this.startX = 0;</span><br><span class="line">        this.startY = 0;</span><br><span class="line">        this.sourceX = 0;</span><br><span class="line">        this.sourceY = 0;</span><br><span class="line"></span><br><span class="line">        this.init();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 原型</span><br><span class="line">      Drag.prototype = &#123;</span><br><span class="line">        constructor: Drag,</span><br><span class="line"></span><br><span class="line">        init: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          // 初始时需要做些什么事情</span><br><span class="line">          this.setDrag();</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 稍作改造，仅用于获取当前元素的属性，类似于getName</span><br><span class="line">        getStyle: <span class="keyword">function</span>(property) &#123;</span><br><span class="line">          <span class="built_in">return</span> document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(this.elem, <span class="literal">false</span>)[</span><br><span class="line">            property] : this.elem.currentStyle[property];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 用来获取当前元素的位置信息，注意与之前的不同之处</span><br><span class="line">        getPosition: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          var pos = &#123;</span><br><span class="line">            x: 0,</span><br><span class="line">            y: 0</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">            var transformValue = this.getStyle(transform);</span><br><span class="line">            <span class="keyword">if</span> (transformValue == <span class="string">'none'</span>) &#123;</span><br><span class="line">              this.elem.style[transform] = <span class="string">'translate(0, 0)'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              var temp = transformValue.match(/-?\d+/g);</span><br><span class="line">              pos = &#123;</span><br><span class="line">                x: parseInt(temp[4].trim()),</span><br><span class="line">                y: parseInt(temp[5].trim())</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (this.getStyle(<span class="string">'position'</span>) == <span class="string">'static'</span>) &#123;</span><br><span class="line">              this.elem.style.position = <span class="string">'relative'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              pos = &#123;</span><br><span class="line">                x: parseInt(this.getStyle(<span class="string">'left'</span>) ? this.getStyle(<span class="string">'left'</span>) : 0),</span><br><span class="line">                y: parseInt(this.getStyle(<span class="string">'top'</span>) ? this.getStyle(<span class="string">'top'</span>) : 0)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">return</span> pos;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 用来设置当前元素的位置</span><br><span class="line">        setPostion: <span class="keyword">function</span>(pos) &#123;</span><br><span class="line">          <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">            this.elem.style[transform] = <span class="string">'translate('</span> + pos.x + <span class="string">'px, '</span> + pos.y + <span class="string">'px)'</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            this.elem.style.left = pos.x + <span class="string">'px'</span>;</span><br><span class="line">            this.elem.style.top = pos.y + <span class="string">'px'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 该方法用来绑定事件</span><br><span class="line">        setDrag: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          var self = this;</span><br><span class="line">          this.elem.addEventListener(<span class="string">'mousedown'</span>, start, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">function</span> start(event) &#123;</span><br><span class="line">            self.startX = event.pageX;</span><br><span class="line">            self.startY = event.pageY;</span><br><span class="line"></span><br><span class="line">            var pos = self.getPosition();</span><br><span class="line"></span><br><span class="line">            self.sourceX = pos.x;</span><br><span class="line">            self.sourceY = pos.y;</span><br><span class="line"></span><br><span class="line">            document.addEventListener(<span class="string">'mousemove'</span>, move, <span class="literal">false</span>);</span><br><span class="line">            document.addEventListener(<span class="string">'mouseup'</span>, end, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">function</span> move(event) &#123;</span><br><span class="line">            var currentX = event.pageX;</span><br><span class="line">            var currentY = event.pageY;</span><br><span class="line"></span><br><span class="line">            var distanceX = currentX - self.startX;</span><br><span class="line">            var distanceY = currentY - self.startY;</span><br><span class="line"></span><br><span class="line">            self.setPostion(&#123;</span><br><span class="line">              x: (self.sourceX + distanceX).toFixed(),</span><br><span class="line">              y: (self.sourceY + distanceY).toFixed()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">function</span> end(event) &#123;</span><br><span class="line">            document.removeEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">            document.removeEventListener(<span class="string">'mouseup'</span>, end);</span><br><span class="line">            // <span class="keyword">do</span> other things</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 私有方法，仅仅用来获取transform的兼容写法</span><br><span class="line">      <span class="keyword">function</span> <span class="function"><span class="title">getTransform</span></span>() &#123;</span><br><span class="line">        var transform = <span class="string">''</span>,</span><br><span class="line">          divStyle = document.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">          transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">          i = 0,</span><br><span class="line">          len = transformArr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">            <span class="built_in">return</span> transform = transformArr[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> transform;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 一种对外暴露的方式</span><br><span class="line">      window.Drag = Drag;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    // 通过扩展方法将拖拽扩展为jQuery的一个实例方法</span><br><span class="line">    (<span class="keyword">function</span> ($) &#123;</span><br><span class="line">      $.fn.extend(&#123;</span><br><span class="line">        becomeDrag: <span class="keyword">function</span> (selector) &#123;</span><br><span class="line">          new Drag(selector);</span><br><span class="line">          <span class="built_in">return</span> this;   // 注意：为了保证jQuery所有的方法都能够链式访问，每一个方法的最后都需要返回this，即返回jQuery实例</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)(jQuery);</span><br><span class="line">    </span><br><span class="line">    // 使用</span><br><span class="line">    $.fn.becomeDrag(<span class="string">'target'</span>);</span><br><span class="line">    $.fn.becomeDrag(<span class="string">'target2'</span>);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着前端的迅猛发展，另外几种前端框架的崛起，jQuery慢慢变得不再是必须。但是我认为，项目中可以不用，但是仍然建议学。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="jQuery" scheme="https://www.chenkl.vip/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(十一)--面向对象实战之封装拖拽对象</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%B8%80)--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8B%96%E6%8B%BD%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%B8%80)--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E5%B0%81%E8%A3%85%E6%8B%96%E6%8B%BD%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-08-16T09:52:49.000Z</published>
    <updated>2020-08-22T02:51:25.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章将会进入一个实战环节：利用之前所涉及到的知识，封装一个拖拽对象。为了能够更好的了解更多的方式与进行对比，下面将会使用两种不同的方式来实现拖拽。</p></blockquote><a id="more"></a><ul><li>不封装对象直接实现</li><li>利用原生JavaScript封装拖拽对象</li></ul><h2 id="如何让一个DOM元素动起来"><a href="#如何让一个DOM元素动起来" class="headerlink" title="如何让一个DOM元素动起来"></a>如何让一个DOM元素动起来</h2><blockquote><p>我们常常会通过修改元素的<code>top,left,translate</code>来使其的位置发生改变。下面的例子中，每点击一次按钮，对象的元素就会移动5px。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        left: 0;</span><br><span class="line">        background-color: orange;</span><br><span class="line">        color: <span class="comment">#fff;</span></span><br><span class="line">        text-align: center;</span><br><span class="line">        line-height: 100px;</span><br><span class="line">        margin: 5px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      button &#123;</span><br><span class="line">        height: 40px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=<span class="string">"elem1"</span>&gt;elem1&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"elem2"</span>&gt;elem2&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button class=<span class="string">"moveLeft"</span>&gt;点击修改left移动&lt;/button&gt;</span><br><span class="line">    &lt;button class=<span class="string">"moveTranslate"</span>&gt;修改translate移动&lt;/button&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    var elem1 = document.querySelector(<span class="string">'.elem1'</span>);</span><br><span class="line">    var elem2 = document.querySelector(<span class="string">'.elem2'</span>);</span><br><span class="line"></span><br><span class="line">    var btn1 = document.querySelector(<span class="string">'.moveLeft'</span>);</span><br><span class="line">    var btn2 = document.querySelector(<span class="string">'.moveTranslate'</span>);</span><br><span class="line"></span><br><span class="line">    var left = 0;</span><br><span class="line">    var translateX = 0;</span><br><span class="line"></span><br><span class="line">    btn1.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      left = left + 5;</span><br><span class="line">      elem1.style.left = left + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btn2.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      translateX += 5;</span><br><span class="line">      elem2.style.transform = <span class="string">'translateX('</span> + translateX + <span class="string">'px)'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>由于修改一个元素的top/left值会引起页面的重绘，而translate不会，因此从性能优化上来判断，我们会优先使用translate属性。</p>          </div><h2 id="如何获取当前浏览器支持的transform兼容写法"><a href="#如何获取当前浏览器支持的transform兼容写法" class="headerlink" title="如何获取当前浏览器支持的transform兼容写法"></a>如何获取当前浏览器支持的transform兼容写法</h2><blockquote><p>transform是css3的属性，当我们使用它时就不得不面对兼容性的问题。不同版本浏览器的兼容写法大致有如下几种：<code>[&#39;transform&#39;, &#39;webkitTransform&#39;, &#39;MozTransform&#39;, &#39;msTransform&#39;, &#39;OTransform&#39;]</code></p></blockquote><blockquote><p>因此我们需要判断当前浏览器环境支持的transform属性是哪一种。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前浏览器支持的transform兼容写法</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getTransform</span></span>() &#123;</span><br><span class="line">  var transform = <span class="string">''</span>,</span><br><span class="line">    divStyle = document.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">    // 可能涉及到的几种兼容性写法，通过循环找出浏览器识别的那一个</span><br><span class="line">    transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">    i = 0,</span><br><span class="line">    len = transformArr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">      // 找到之后立即返回，结束函数</span><br><span class="line">      <span class="built_in">return</span> transform = transformArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果没有找到，就直接返回空字符串</span><br><span class="line">  <span class="built_in">return</span> transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法用于获取浏览器支持的transform属性。如果返回的为空字符串，则表示当前浏览器并不支持transform，这个时候我们就需要使用left，top值来改变元素的位置。如果支持，就改变transform值。</p></blockquote><h2 id="如何获取元素的初始位置"><a href="#如何获取元素的初始位置" class="headerlink" title="如何获取元素的初始位置"></a>如何获取元素的初始位置</h2><blockquote><p>首先需要获取到目标元素的初始位置，因此这里需要一个专门用来获取元素样式的功能函数。但是获取元素样式在IE浏览器与其他浏览器有一些不同，我们需要一个兼容性的写法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getStyle(elem, property) &#123;</span><br><span class="line">  // ie通过currentStyle来获取元素的样式，其他浏览器通过getComputedStyle来获取</span><br><span class="line">  <span class="built_in">return</span> document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(elem, <span class="literal">false</span>)[property] : elem.currentStyle[property];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有了这个方法之后，就可以开始动手写获取目标元素初始位置的方法了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getTargetPos(elem) &#123;</span><br><span class="line">  var pos = &#123; x: 0, y: 0 &#125;</span><br><span class="line">  var transform = getTransform()</span><br><span class="line">  <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">    var transformValue = getStyle(elem, transform)</span><br><span class="line">    <span class="keyword">if</span> (transformValue === <span class="string">'none'</span>) &#123;</span><br><span class="line">      elem.style[transform] = <span class="string">'translate(0, 0)'</span></span><br><span class="line">      <span class="built_in">return</span> pos</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      var temp = transformValue.match(/-?\d+/g)</span><br><span class="line">      <span class="built_in">return</span> pos = &#123;</span><br><span class="line">        x: parseInt(temp[4].trim()),</span><br><span class="line">        y: parseInt(temp[5].trim())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getStyle(elem, <span class="string">'position'</span>) === <span class="string">'static'</span>) &#123;</span><br><span class="line">      elem.style.position = <span class="string">'relative'</span></span><br><span class="line">      <span class="built_in">return</span> pos</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      var x = parseInt(getStyle(elem, <span class="string">'left'</span>) ? getStyle(elem, <span class="string">'left'</span>) : 0)</span><br><span class="line">      var y = parseInt(getStyle(elem, <span class="string">'top'</span>) ? getStyle(elem, <span class="string">'top'</span>) : 0)</span><br><span class="line">      <span class="built_in">return</span> pos = &#123;</span><br><span class="line">        x: x,</span><br><span class="line">        y: y</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在拖拽过程中，我们需要不停的设置目标元素的新位置，这样它才能移动起来，因此我们需要一个设置目标元素位置的方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// pos = &#123; x: 200, y: 100 &#125;</span><br><span class="line"><span class="keyword">function</span> setTargetPos(elem, pos) &#123;</span><br><span class="line">  var transform = getTransform()</span><br><span class="line">  <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">    elem.style[transform] = <span class="string">'translate('</span> + pos.x + <span class="string">'px, '</span> + pos.y + <span class="string">'px)'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elem.style.left = pos.x + <span class="string">'px'</span></span><br><span class="line">    elem.style.top = pos.y + <span class="string">'px'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我们需要用到哪些事件"><a href="#我们需要用到哪些事件" class="headerlink" title="我们需要用到哪些事件"></a>我们需要用到哪些事件</h2><blockquote><p>在pc上的浏览器中，结合<code>mousedown、mousemove、mouseup</code>这三个事件可以帮助我们实现拖拽。</p></blockquote><ul><li>mousedown 鼠标按下时触发</li><li>mousemove 鼠标按下后拖动时触发</li><li>mouseup 鼠标松开时触发</li></ul><div class="note info">            <p>而在移动端，分别与之对应的则是touchstart、touchmove、touchend。</p>          </div><blockquote><p>当我们将元素绑定这些事件时，有一个事件对象将会作为参数传递给回调函数，通过事件对象，我们可以获取到当前鼠标的精确位置，鼠标位置信息是实现拖拽的关键。</p></blockquote><h2 id="拖拽的原理"><a href="#拖拽的原理" class="headerlink" title="拖拽的原理"></a>拖拽的原理</h2><blockquote><p>当事件触发时，我们可以通过事件对象获取到鼠标的精确位置。这就是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据厂里我们可以得出如下关系。</p></blockquote><div class="note info">            <p>移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置</p>          </div><blockquote><p>如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：</p></blockquote><div class="note info">            <p>移动后目标元素的位置 = dis + 目标元素的初始位置</p>          </div><blockquote><p>通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。</p></blockquote><blockquote><p>而在鼠标松开(mouseup)结束拖拽时，我们需要处理一些收尾工作。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200816102259.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取目标元素对象</span><br><span class="line">var oElem = document.getElementById(<span class="string">'target'</span>)</span><br><span class="line"></span><br><span class="line">// 声明2个变量用来保存鼠标初始位置的x，y坐标</span><br><span class="line">var startX = 0</span><br><span class="line">var startY = 0</span><br><span class="line"></span><br><span class="line">// 声明2个变量用来保存目标元素初始位置的x，y坐标</span><br><span class="line">var sourceX = 0</span><br><span class="line">var sourceY = 0</span><br></pre></td></tr></table></figure><h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><blockquote><p>因为之前已经贴过代码，就不再重复</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前浏览器支持的transform兼容写法</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getTransform</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 获取元素属性</span><br><span class="line"><span class="keyword">function</span> getStyle(elem, property) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 获取元素的初始位置</span><br><span class="line"><span class="keyword">function</span> getTargetPos(elem) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 设置元素的初始位置</span><br><span class="line"><span class="keyword">function</span> setTargetPos(elem, potions) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="声明三个事件的回调函数"><a href="#声明三个事件的回调函数" class="headerlink" title="声明三个事件的回调函数"></a>声明三个事件的回调函数</h3><blockquote><p>这三个方法就是实现拖拽的核心所在</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 绑定在mousedown上的回调，event为传入的事件对象</span><br><span class="line"><span class="keyword">function</span> start(event) &#123;</span><br><span class="line">  // 获取鼠标初始位置</span><br><span class="line">  startX = event.pageX</span><br><span class="line">  startY = event.pageY</span><br><span class="line"></span><br><span class="line">  // 获取元素初始位置</span><br><span class="line">  var pos = getTargetPos(oElem)</span><br><span class="line"></span><br><span class="line">  sourceX = pos.x</span><br><span class="line">  sourceY = pos.y</span><br><span class="line"></span><br><span class="line">  // 绑定</span><br><span class="line">  document.addEventListener(<span class="string">'mousemove'</span>, move, <span class="literal">false</span>)</span><br><span class="line">  document.addEventListener(<span class="string">'mouseup'</span>, end, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> move(event) &#123;</span><br><span class="line">  // 获取鼠标当前位置</span><br><span class="line">  var currentX = event.pageX</span><br><span class="line">  var currentY = event.pageY</span><br><span class="line"></span><br><span class="line">  // 计算差值</span><br><span class="line">  var distanceX = currentX - startX</span><br><span class="line">  var distanceY = currentY - startY</span><br><span class="line"></span><br><span class="line">  // 计算并设置元素当前位置</span><br><span class="line">  setTargetPos(oElem, &#123;</span><br><span class="line">    x: (sourceX + distanceX).toFixed(),</span><br><span class="line">    y: (sourceY + distanceY).toFixed()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> end(event) &#123;</span><br><span class="line">  document.removeEventListener(<span class="string">'mousemove'</span>, move)</span><br><span class="line">  document.removeEventListener(<span class="string">'mouseup'</span>, end)</span><br><span class="line">  // <span class="keyword">do</span> other things</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整拖拽代码如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">      <span class="comment">#target &#123;</span></span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        background-color: orange;</span><br><span class="line">        cursor: move;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"target"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    var oElem = document.getElementById(<span class="string">'target'</span>);</span><br><span class="line"></span><br><span class="line">    var startX = 0;</span><br><span class="line">    var startY = 0;</span><br><span class="line"></span><br><span class="line">    var sourceX = 0;</span><br><span class="line">    var sourceY = 0;</span><br><span class="line"></span><br><span class="line">    oElem.addEventListener(<span class="string">'mousedown'</span>, start, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> start(event) &#123;</span><br><span class="line">      startX = event.pageX;</span><br><span class="line">      startY = event.pageY;</span><br><span class="line"></span><br><span class="line">      var pos = getTargetPos(oElem);</span><br><span class="line"></span><br><span class="line">      sourceX = pos.x;</span><br><span class="line">      sourceY = pos.y;</span><br><span class="line"></span><br><span class="line">      document.addEventListener(<span class="string">'mousemove'</span>, move, <span class="literal">false</span>);</span><br><span class="line">      document.addEventListener(<span class="string">'mouseup'</span>, end, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> move(event) &#123;</span><br><span class="line">      var currentX = event.pageX;</span><br><span class="line">      var currentY = event.pageY;</span><br><span class="line"></span><br><span class="line">      var distanceX = currentX - startX;</span><br><span class="line">      var distanceY = currentY - startY;</span><br><span class="line"></span><br><span class="line">      setTargetPos(oElem, &#123;</span><br><span class="line">        x: (sourceX + distanceX).toFixed(),</span><br><span class="line">        y: (sourceY + distanceY).toFixed()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> end(event) &#123;</span><br><span class="line">      document.removeEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">      document.removeEventListener(<span class="string">'mouseup'</span>, end);</span><br><span class="line">      // <span class="keyword">do</span> other things</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> getStyle(elem, property) &#123;</span><br><span class="line">      // 低版本ie通过currentStyle来获取元素的样式，其他浏览器通过getComputedStyle来获取</span><br><span class="line">      <span class="built_in">return</span> document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(elem, <span class="literal">false</span>)[property] :</span><br><span class="line">        elem.currentStyle[property];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">getTransform</span></span>() &#123;</span><br><span class="line">      var transform = <span class="string">''</span>,</span><br><span class="line">        divStyle = document.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">        transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">        i = 0,</span><br><span class="line">        len = transformArr.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">          <span class="built_in">return</span> transform = transformArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">return</span> transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> getTargetPos(elem) &#123;</span><br><span class="line">      var pos = &#123;</span><br><span class="line">        x: 0,</span><br><span class="line">        y: 0</span><br><span class="line">      &#125;;</span><br><span class="line">      var transform = getTransform();</span><br><span class="line">      // transform = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">        var transformValue = getStyle(elem, transform);</span><br><span class="line">        <span class="keyword">if</span> (transformValue == <span class="string">'none'</span>) &#123;</span><br><span class="line">          elem.style[transform] = <span class="string">'translate(0, 0)'</span>;</span><br><span class="line">          <span class="built_in">return</span> pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          var temp = transformValue.match(/[0-9,\s\.]+/)[0].split(<span class="string">','</span>);</span><br><span class="line">          <span class="built_in">return</span> pos = &#123;</span><br><span class="line">            x: parseInt(temp[4].trim()),</span><br><span class="line">            y: parseInt(temp[5].trim())</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getStyle(elem, <span class="string">'position'</span>) == <span class="string">'static'</span>) &#123;</span><br><span class="line">          elem.style.position = <span class="string">'relative'</span>;</span><br><span class="line">          <span class="built_in">return</span> pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          var x = parseInt(getStyle(elem, <span class="string">'left'</span>) ? getStyle(elem, <span class="string">'left'</span>) : 0);</span><br><span class="line">          var y = parseInt(getStyle(elem, <span class="string">'top'</span>) ? getStyle(elem, <span class="string">'top'</span>) : 0);</span><br><span class="line">          <span class="built_in">return</span> pos = &#123;</span><br><span class="line">            x: x,</span><br><span class="line">            y: y</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // pos = &#123; x: 200, y: 100 &#125;</span><br><span class="line">    <span class="keyword">function</span> setTargetPos(elem, pos) &#123;</span><br><span class="line">      var transform = getTransform();</span><br><span class="line">      <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">        elem.style[transform] = <span class="string">'translate('</span> + pos.x + <span class="string">'px, '</span> + pos.y + <span class="string">'px)'</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elem.style.left = pos.x + <span class="string">'px'</span>;</span><br><span class="line">        elem.style.top = pos.y + <span class="string">'px'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="封装拖拽对象"><a href="#封装拖拽对象" class="headerlink" title="封装拖拽对象"></a>封装拖拽对象</h2><blockquote><p>我们的目标是，只要我们声明一个拖拽实例，那么传入的目标元素讲自动具备可以拖拽的功能。</p></blockquote><blockquote><p>在实际开发中，一个对象我们常常会单独放在一个JavaScript文件中，这个JavaScript文件讲单独作为一个模块，利用各种模块的方式组织起来使用。当然这里没有复杂的模块交互，因为这个例子，我们只需要一个模块即可。</p></blockquote><blockquote><p>为了避免变量污染，我们需要将模块放置于一个函数自执行方式模拟的块级作用域中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><div class="note info">            <p>在普通的模块组织中，我们只是单纯的将许多JavaScript文件压缩成为一个JavaScript文件，因此此处的第一个分号则是为了防止上一个模块的结尾不用分号导致报错，必不可少。当然在通过require或者ES6模块等方式就不会出现这样的情况。</p>          </div><blockquote><p>我们知道，在封装一个对象的时候，可以将属性与方法放置于构造函数或者原型中，而在增加了自执行函数之后，我们又可以将属性与方法放置于模块的内部作用于。这就是闭包的知识。</p></blockquote><blockquote><p><code>那么我们将如何合理的处理属性与方法的位置。</code></p></blockquote><blockquote><p>每一个对象的情况都不一样，不能一概而论，我们需要清洗的知道这三种位置的特性才能做出最合适的决定。</p></blockquote><ul><li>构造函数中：属性与方法为当前实例单独拥有，只能被当前实例访问，并且每声明一个实例，其中的方法都会被重新创建一次。</li><li>原型中：属性与方法为所有实例共同拥有，可以被所有实例访问，新声明实例不会重复创建方法。</li><li>模块作用域中：属性和方法不能被任何实例访问，但是能被内部方法访问，新声明的实例，不会重复创建相同的方法。</li></ul><blockquote><p><code>对于方法的判断比较简单</code></p></blockquote><blockquote><p>因为在构造函数中的方法总会声明一个新的实例时被重复创建，因此我们声明的方法都尽量避免出现在构造函数中。</p></blockquote><blockquote><p>而如果你的方法中需要用到构造函数中的变量，或者想要公开，那就需要放在原型中。</p></blockquote><blockquote><p>如果方法需要私有不被外界访问，那么就放置在模块作用域中。</p></blockquote><blockquote><p><code>对于属性的判断</code></p></blockquote><blockquote><p>如果属性值只能被实例单独拥有，比如person对象的name，只能属于某一个person实例，又比如这里拖拽对象中，某一个元素的初始位置，也仅仅只是这个元素的当前位置，这个属性，则适合放在构造函数中。</p></blockquote><blockquote><p>而如果一个属性仅仅供内部方法访问，这个属性就适合放在模块作用域中。</p></blockquote><blockquote><p>完整代码如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">      <span class="comment">#target,</span></span><br><span class="line">      <span class="comment">#target2 &#123;</span></span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        background-color: orange;</span><br><span class="line">        cursor: move;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">#target2 &#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"target"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"target2"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    ;</span><br><span class="line">    (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      // 这是一个私有属性，不需要被实例访问</span><br><span class="line">      var transform = getTransform();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> Drag(selector) &#123;</span><br><span class="line">        // 放在构造函数中的属性，都是属于每一个实例单独拥有</span><br><span class="line">        this.elem = typeof selector == <span class="string">'Object'</span> ? selector : document.getElementById(selector);</span><br><span class="line">        this.startX = 0;</span><br><span class="line">        this.startY = 0;</span><br><span class="line">        this.sourceX = 0;</span><br><span class="line">        this.sourceY = 0;</span><br><span class="line"></span><br><span class="line">        this.init();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 原型</span><br><span class="line">      Drag.prototype = &#123;</span><br><span class="line">        constructor: Drag,</span><br><span class="line"></span><br><span class="line">        init: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          // 初始时需要做些什么事情</span><br><span class="line">          this.setDrag();</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 稍作改造，仅用于获取当前元素的属性，类似于getName</span><br><span class="line">        getStyle: <span class="keyword">function</span>(property) &#123;</span><br><span class="line">          <span class="built_in">return</span> document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(this.elem, <span class="literal">false</span>)[</span><br><span class="line">            property] : this.elem.currentStyle[property];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 用来获取当前元素的位置信息，注意与之前的不同之处</span><br><span class="line">        getPosition: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          var pos = &#123;</span><br><span class="line">            x: 0,</span><br><span class="line">            y: 0</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">            var transformValue = this.getStyle(transform);</span><br><span class="line">            <span class="keyword">if</span> (transformValue == <span class="string">'none'</span>) &#123;</span><br><span class="line">              this.elem.style[transform] = <span class="string">'translate(0, 0)'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              var temp = transformValue.match(/-?\d+/g);</span><br><span class="line">              pos = &#123;</span><br><span class="line">                x: parseInt(temp[4].trim()),</span><br><span class="line">                y: parseInt(temp[5].trim())</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (this.getStyle(<span class="string">'position'</span>) == <span class="string">'static'</span>) &#123;</span><br><span class="line">              this.elem.style.position = <span class="string">'relative'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              pos = &#123;</span><br><span class="line">                x: parseInt(this.getStyle(<span class="string">'left'</span>) ? this.getStyle(<span class="string">'left'</span>) : 0),</span><br><span class="line">                y: parseInt(this.getStyle(<span class="string">'top'</span>) ? this.getStyle(<span class="string">'top'</span>) : 0)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">return</span> pos;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 用来设置当前元素的位置</span><br><span class="line">        setPostion: <span class="keyword">function</span>(pos) &#123;</span><br><span class="line">          <span class="keyword">if</span> (transform) &#123;</span><br><span class="line">            this.elem.style[transform] = <span class="string">'translate('</span> + pos.x + <span class="string">'px, '</span> + pos.y + <span class="string">'px)'</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            this.elem.style.left = pos.x + <span class="string">'px'</span>;</span><br><span class="line">            this.elem.style.top = pos.y + <span class="string">'px'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 该方法用来绑定事件</span><br><span class="line">        setDrag: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          var self = this;</span><br><span class="line">          this.elem.addEventListener(<span class="string">'mousedown'</span>, start, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">function</span> start(event) &#123;</span><br><span class="line">            self.startX = event.pageX;</span><br><span class="line">            self.startY = event.pageY;</span><br><span class="line"></span><br><span class="line">            var pos = self.getPosition();</span><br><span class="line"></span><br><span class="line">            self.sourceX = pos.x;</span><br><span class="line">            self.sourceY = pos.y;</span><br><span class="line"></span><br><span class="line">            document.addEventListener(<span class="string">'mousemove'</span>, move, <span class="literal">false</span>);</span><br><span class="line">            document.addEventListener(<span class="string">'mouseup'</span>, end, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">function</span> move(event) &#123;</span><br><span class="line">            var currentX = event.pageX;</span><br><span class="line">            var currentY = event.pageY;</span><br><span class="line"></span><br><span class="line">            var distanceX = currentX - self.startX;</span><br><span class="line">            var distanceY = currentY - self.startY;</span><br><span class="line"></span><br><span class="line">            self.setPostion(&#123;</span><br><span class="line">              x: (self.sourceX + distanceX).toFixed(),</span><br><span class="line">              y: (self.sourceY + distanceY).toFixed()</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">function</span> end(event) &#123;</span><br><span class="line">            document.removeEventListener(<span class="string">'mousemove'</span>, move);</span><br><span class="line">            document.removeEventListener(<span class="string">'mouseup'</span>, end);</span><br><span class="line">            // <span class="keyword">do</span> other things</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 私有方法，仅仅用来获取transform的兼容写法</span><br><span class="line">      <span class="keyword">function</span> <span class="function"><span class="title">getTransform</span></span>() &#123;</span><br><span class="line">        var transform = <span class="string">''</span>,</span><br><span class="line">          divStyle = document.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">          transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">          i = 0,</span><br><span class="line">          len = transformArr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">            <span class="built_in">return</span> transform = transformArr[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> transform;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 一种对外暴露的方式</span><br><span class="line">      window.Drag = Drag;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    // 使用：声明2个拖拽实例</span><br><span class="line">    new Drag(<span class="string">'target'</span>);</span><br><span class="line">    new Drag(<span class="string">'target2'</span>);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇文章将会进入一个实战环节：利用之前所涉及到的知识，封装一个拖拽对象。为了能够更好的了解更多的方式与进行对比，下面将会使用两种不同的方式来实现拖拽。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="面向对象" scheme="https://www.chenkl.vip/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="拖拽" scheme="https://www.chenkl.vip/tags/%E6%8B%96%E6%8B%BD/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(十)--面向对象、构造函数、原型与原型链</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81)--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%8D%81)--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-08-15T09:15:00.000Z</published>
    <updated>2020-08-22T02:51:35.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结了一下我学习前端以来我遇到了哪些瓶颈，那么面向对象一定是第一个想到的。尽管现在对于面向对象有了一些了解，但是那种似懂非懂的感觉，依然历历在目。</p></blockquote><a id="more"></a><h2 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h2><blockquote><p>对象被定义为<code>无序属性的集合，其属性可以包含基本值，对象或者函数</code>。</p></blockquote><blockquote><p>也就是说，在JavaScript中，对象无非就是由一些无序的<code>key-value</code>对组成。其中value可以是基本知识，对象或者函数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这里的person就是一个对象</span><br><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: 18,</span><br><span class="line">  getName: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">  parent: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><blockquote><p>我们可以通过new的方式创建一个对象。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object()</span><br></pre></td></tr></table></figure><blockquote><p>也可以通过对象字面量的形式创建一个简单的对象。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当想要给我们创建的简单对象添加方法时，可以这样表示</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 可以这样</span><br><span class="line">var person &#123;&#125;</span><br><span class="line">person.name = <span class="string">'Tom'</span></span><br><span class="line">person.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可以这样</span><br><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  getName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问对象的属性和方法"><a href="#访问对象的属性和方法" class="headerlink" title="访问对象的属性和方法"></a>访问对象的属性和方法</h3><blockquote><p>假如我们有一个简单的对象如下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: <span class="string">'20'</span>,</span><br><span class="line">  getName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们想要访问他的name属性时，可以用如下两种方式访问。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.name</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">person[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果想要访问的属性名是一个变量时，常常会使用第二种方式，例如我们要同时访问person的name和age，可以这样写。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'name'</span>, <span class="string">'age'</span>].forEach(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">  console.log(person[item])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求。就以person对象为例，假如在实际开发中，不仅仅需要一个名字叫做Tom的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var perTom = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: 20,</span><br><span class="line">  getName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var perJake = &#123;</span><br><span class="line">  name: <span class="string">'Jake'</span>,</span><br><span class="line">  age: 22,</span><br><span class="line">  getName: <span class="function"><span class="title">fucntion</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很显然这并不是合理的方式，我们可以使用工厂模式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出需要的对象，我们需要多少个，就复制多少个。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var createPerson = <span class="keyword">function</span>(name, age) &#123;</span><br><span class="line">  // 声明一个中间对象，该对象就是工厂模式的模子</span><br><span class="line">  var o = new Object()</span><br><span class="line">  </span><br><span class="line">  // 依次添加我们需要的属性和方法</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建两个实例</span><br><span class="line">var perTom = createPerson(<span class="string">'Tom'</span>, 20)</span><br><span class="line">var perJake = createPerson(<span class="string">'Jake'</span>, 22)</span><br></pre></td></tr></table></figure><blockquote><p>相信上面的代码并不难理解，也不用把工厂模式看的太过高大上，很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里有两个麻烦，我们需要注意。</p></blockquote><blockquote><p>第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。使用instanceof可以识别对象的类型。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">var foo = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj instanceof Object) // <span class="literal">true</span></span><br><span class="line">console.log(foo instanceof Fcuntion) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>在JavaScript中，new关键字可以让一个函数变得与众不同。通过下面的例子，我们来看看new关键字的神奇之处。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">demo</span></span>() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo() // window</span><br><span class="line">new demo() // demo</span><br></pre></td></tr></table></figure><blockquote><p>很显然，使用new之后，函数内部发生了事情，让this指向改变。</p></blockquote><blockquote><p>我们可以通过代码来理解一下new关键字到底做了什么</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个构造函数，其实该构造函数与普通函数并无区别</span><br><span class="line">var Person = <span class="keyword">function</span>(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将构造函数以参数的形式传入</span><br><span class="line"><span class="keyword">function</span> New(func) &#123;</span><br><span class="line">  // 声明一个中间对象，该对象为最终返回的实例</span><br><span class="line">  var res = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (func.prototype !== null) &#123;</span><br><span class="line">    // 将实例的原型指向构造函数的原型</span><br><span class="line">    res.__proto__ = func.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this改为指向res，即为实例对象</span><br><span class="line">  var ret = func.apply(res, Array.prototype.slice.call(arguments, 1))</span><br><span class="line">  </span><br><span class="line">  // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span><br><span class="line">  <span class="keyword">if</span> ((typeof ret === <span class="string">'object'</span> || typeof ret === <span class="string">'function'</span>) &amp;&amp; ret !== null) &#123;</span><br><span class="line">    <span class="built_in">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span><br><span class="line">  <span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span><br><span class="line">var p1 = New(Person, <span class="string">'Tom'</span>, 20)</span><br><span class="line">console.log(p1.getName())</span><br><span class="line"></span><br><span class="line">// 当然，这里也可以判断出实例的类型了</span><br><span class="line">console.log(p1 instanceof Person) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>JavaScript内部在通过其他的一些特殊处理，将<code>var p1 = New(Person, &#39;Tom&#39;, 20)</code>等效于<code>var p1 = new Person(&#39;Tom&#39;, 20)</code>。就是我们认识的new关键字了。</p>          </div><blockquote><p>理解了他的原理，那么困扰了无数人的构造函数中this到底指向谁就变得非常简单了。所以，为了能够判断实例与对象的关系，我们就使用构造函数来搞定。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Person = <span class="keyword">function</span>(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(<span class="string">'Tom'</span>, 20)</span><br><span class="line">console.log(p1.getName()) // Tom</span><br><span class="line"></span><br><span class="line">console.log(p1 instanceof Person) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。</p></blockquote><ul><li>与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数</li><li>new 关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程<ol><li>声明一个中间对象</li><li>将该中间对象的原型指向构造函数的原型</li><li>将构造函数的this，指向该中间对象</li><li>返回该中间对象，即返回实例对象</li></ol></li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><blockquote><p>虽然构造函数解决了判断实例类型的问题，但是，说到底，还是一个对象的复制过程。跟工厂模式颇有相似之处。也就是说，当我们声明了100个person对象，那么就有100个getName方法被重新生成。</p></blockquote><blockquote><p>这里的每一个getName方法实现的功能其实是一模一样的，但是由于分别属于不同实例，就不得不一直不停的为getName分配空间。这就是工厂模式存在的第二个麻烦。</p></blockquote><blockquote><p>虽然这是不合理的，我们期望的是，既然都是实现同一个功能，那么能不能就让每一个实例对象都访问同一个方法？这就是原型对象要帮我们解决的问题了。</p></blockquote><blockquote><p>我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是我们这里说的原型。</p></blockquote><blockquote><p>当我们在创建对象时，可以根据自己的需求，选择性的讲一些属性和方法通过prototype属性，挂载在原型对象中。而每一个new出来的实例，都有一个<strong>proto</strong>属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象的方法。因此，当所有的实例都通过<strong>proto</strong>访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。</p></blockquote><div class="note info">            <p>由于每个函数都可以是构造函数，每个对象都可以是原型对象，因此如果在理解原型之初就想的太多太复杂的话，反而会阻碍你的理解，这里我们要学会先简化它们。就单纯的剖析这三者的关系。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明构造函数</span><br><span class="line"><span class="keyword">function</span> Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过prototype属性，将方法挂载到原型对象上</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(<span class="string">'tim'</span>, 20)</span><br><span class="line">var p2 = new Person(<span class="string">'jak'</span>, 22)</span><br><span class="line">console.log(p1.getName === p2.getName) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200815154907.png" alt=""></p><blockquote><p>通过图示我们可以看出，构造函数的prototype与所有实例对象的<strong>proto</strong>都指向原型对象。而原型对象的constructor指向构造函数。</p></blockquote><blockquote><p>除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。</p></blockquote><blockquote><p>当我们访问实例对象中的属性或者方法时，会有限访问实例对象自身的属性和方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is constructor.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(<span class="string">'tim'</span>, 10)</span><br><span class="line"></span><br><span class="line">p1.getName() // this is constructor.</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。</p></blockquote><blockquote><p>我们还可以通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在于实例对象或者原型对象。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(<span class="string">'tim'</span>, 10)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'name'</span> <span class="keyword">in</span> p1) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isMobile = <span class="string">'ontouchstart'</span> <span class="keyword">in</span> document</span><br><span class="line">// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式</span><br></pre></td></tr></table></figure><h3 id="更简单的原型写法"><a href="#更简单的原型写法" class="headerlink" title="更简单的原型写法"></a>更简单的原型写法</h3><blockquote><p>根据前面的例子的写法，如果我们要在原型上添加更多的方法，可以这样写</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><blockquote><p>除此之外，我们还可以使用更为之简单的写法</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  getName: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">  getAge: <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">  sayHello: <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。<code>Person.prototype = {}</code>实际上是重新创建了一个{}对象并赋值给Person.prototype，这里的{}并不是最初的那个原型对象。因此它里面并不包含constructor属性。为了保证正确性，我们必须在新创建的{}对象中显示的设置constructor的指向。即上面的<code>constructor: Person</code>。</p></blockquote><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><blockquote><p>原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实力对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构造原型链的一个节点。因此理解了原型，那么原型链并不是一个多么复杂的概念。</p></blockquote><blockquote><p>我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？</p></blockquote><blockquote><p>先随意声明一个函数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么我们可以用如下的图来表示这个函数的原型链。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200815160412.png" alt=""></p><blockquote><p>其中add是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链对象上的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。</p></blockquote><blockquote><p>基于原型链的特性，我们可以很轻松的实现<code>继承</code>。</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须根据构造函数与原型的不同而采取不同的策略。</p></blockquote><blockquote><p>我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的是，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数继承</span><br><span class="line"><span class="keyword">function</span> cPerson(name, age, job) &#123;</span><br><span class="line">  Person.call(this, name, age)</span><br><span class="line">  this.job = job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原型的继承，只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 继承原型</span><br><span class="line">cPerson.prototype = new Person(name, age)</span><br><span class="line"></span><br><span class="line">// 添加更多的方法</span><br><span class="line">cPerson.prototype.getLive = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200815161326.png" alt=""></p><blockquote><p>当然关于继承还有更好的方式</p></blockquote><h2 id="更好的继承"><a href="#更好的继承" class="headerlink" title="更好的继承"></a>更好的继承</h2><blockquote><p>假设原型链的终点Object.prototype为原型链的E(end)端，原型链的起点为S(start)端。</p></blockquote><blockquote><p>通过前面原型链的学习我们知道，处于S端的对象，可以通过S -&gt; E的单向查找，访问原型链上的所有方法与属性。因此这给继承提供了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。因此想要实现继承，是一件非常简单的事情。</p></blockquote><blockquote><p>因为封装一个对象由构造函数与原型共同组成，因此继承也会分别有构造函数的继承与原型的继承。</p></blockquote><blockquote><p>假设我们已经封装好了一个父级对象Person</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Person = <span class="keyword">function</span>(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数的继承比较简单，我们可以借助call/apply来实现。假设我们通过继承封装一个Student的子类对象。那么构造函数可以如下实现。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Student = <span class="keyword">function</span>(name, age, grade) &#123;</span><br><span class="line">  // 通过call方法还原Person构造函数中的所有处理逻辑</span><br><span class="line">  Person.call(this, name, age)</span><br><span class="line">  this.grade = grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">var Student = <span class="keyword">function</span>(name, age, grade) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.grade = grade</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原型的继承则稍微需要一点思考。首先我们应该考虑，如何将子类对象的原型加入到原型链中？我们只需要让子类对象的原型，成为父类对象的一个实例，然后通过<strong>proto</strong>就可以访问父类对象的原型，这样就继承了父类原型中的方法与属性了。</p></blockquote><blockquote><p>因此我们可以先封装一个方法，该方法根据父类对象的原型创建一个实例，该实例将会作为子类对象的原型。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> create(proto, options) &#123;</span><br><span class="line">  // 创建一个空对象</span><br><span class="line">  var tmp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 让这个新的空对象成为父类对象的实例</span><br><span class="line">  tmp.__proto__ = proto</span><br><span class="line"></span><br><span class="line">  // 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型</span><br><span class="line">  Object.defineProperties(tmp, options)</span><br><span class="line">  <span class="built_in">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单的封装了<code>create</code>对象之后，我们就可以使用该方法来实现原型的继承了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">  // 不要忘了重新指定构造函数</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Student</span><br><span class="line">  &#125;</span><br><span class="line">  getGrade: &#123;</span><br><span class="line">    value: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> this.grade</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>那么我们来验证一下我们这里实现的继承是否正确。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Student(<span class="string">'ming'</span>, 22, 5)</span><br><span class="line"></span><br><span class="line">console.log(s1.getName()) // ming</span><br><span class="line">console.log(s1.getAge()) // 22</span><br><span class="line">console.log(s1.getGrade()) // 5</span><br></pre></td></tr></table></figure><blockquote><p>全部能够正常访问，没问题。在ECMAScript5中直接提供了一个Object.create方法来完成我们上面自己封装的create的功能。因此我们可以直接使用Object.create。</p></blockquote><h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><blockquote><p>在上面的继承实现中，使用了一个大家可能不太熟悉的方法<code>defineProperties</code>，并且在定义<code>getGrade</code>时使用了一个很奇怪的方式。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getGrade: &#123;</span><br><span class="line">  value: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.grade</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这其实是对象中的属性类型。在我们平常的使用中，给对象添加一个属性时，直接使用object.param的方式就可以了，或者直接在对象中挂载。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'TOM'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在ECMAScript5中，对每个属性都添加了几个属性类型，来描述这些属性的特点。他们分别是</p></blockquote><ul><li>configurable: 表示该属性是否能被delete删除。当其值为false时，其他的特性也不能被改变。默认值为true</li><li>enumerable: 是否能枚举。也就是是否能被for-in遍历。默认值为true</li><li>writable: 是否能修改值。默认为true</li><li>value: 该属性的具体值是多少。默认为undefined</li><li>get: 当我们通过person.name访问name的值时，get将被调用。该方法可以自定义返回的具体值是多少。get默认值为undefined</li><li>set: 当我们通过person.name = ‘Jake’设置name的值时，set方法将被调用。该方法可以自定义设置值的具体方式。set默认值为undefined</li></ul><div class="note warning">            <p>需要注意的是，不能同时设置value、writable 与 get、set的值。</p>          </div><blockquote><p>我们可以通过Object.defineProperty方法来修改这些属性类型。下面我们用一些简单的例子来演示一下这些属性类型的具体表现。</p></blockquote><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 用普通的方式给person对象添加一个name属性，值为TOM</span><br><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'TOM'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用delete删除该属性</span><br><span class="line">delete person.name // 返回<span class="literal">true</span> 表示删除成功</span><br><span class="line"></span><br><span class="line">// 通过Object.defineProperty重新添加name属性</span><br><span class="line">// 并设置name的属性类型的configurable为<span class="literal">false</span>，表示不能再用delete删除</span><br><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'Jake'</span> // 设置name属性的值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 再次delete，已经不能删除了</span><br><span class="line">delete person.name // <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">console.log(person.name) // 值为Jake</span><br><span class="line"></span><br><span class="line">// 试图改变value</span><br><span class="line">person.name = <span class="string">'alex'</span></span><br><span class="line">console.log(person.name) // Jake 改变失败</span><br></pre></td></tr></table></figure><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'TOM'</span>,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用<span class="keyword">for</span>-in枚举person的属性</span><br><span class="line">var params = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  params.push(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看枚举结果</span><br><span class="line">console.log(params) // [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">// 重新设置name属性的类型，让其不可被枚举</span><br><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var params_ = []</span><br><span class="line"><span class="keyword">for</span>(var key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  params_.push(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 再次查看枚举结果</span><br><span class="line">console.log(params_) // [<span class="string">'age'</span>]</span><br></pre></td></tr></table></figure><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'TOM'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改name的值</span><br><span class="line">person.name = <span class="string">'Jake'</span></span><br><span class="line"></span><br><span class="line">// 查看修改结果</span><br><span class="line">console.log(person.name) // Jake 修改成功</span><br><span class="line"></span><br><span class="line">// 设置name的值不能被修改</span><br><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 再次试图修改name的值</span><br><span class="line">person.name = <span class="string">'alex'</span></span><br><span class="line"></span><br><span class="line">console.log(person.name) // Jake 修改失败</span><br></pre></td></tr></table></figure><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 添加一个name属性</span><br><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'TOM'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(person.name) // TOM</span><br></pre></td></tr></table></figure><h3 id="get-set"><a href="#get-set" class="headerlink" title="get/set"></a>get/set</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 通过get与<span class="built_in">set</span>自定义访问与设置name属性的方式</span><br><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 一直返回TOM</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'TOM'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">    // 设置name属性时，返回该字符串，value为新值</span><br><span class="line">    console.log(value + <span class="string">' in set'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 第一次访问name，调用get</span><br><span class="line">console.log(person.name) // TOM</span><br><span class="line"></span><br><span class="line">// 尝试修改name值，此时<span class="built_in">set</span>方法被调用</span><br><span class="line">person.name = <span class="string">'alex'</span> // alex <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">// 第二次访问name，还是调用get</span><br><span class="line">console.log(person.name) // TOM</span><br></pre></td></tr></table></figure><div class="note info">            <p>请尽量同时设置get、set。如果仅仅只设置了get，那么我们将无法设置该属性值。如果仅仅只设置了set，我们也无法读取该属性的值。</p>          </div><blockquote><p>Object.defineProperty只能设置一个属性的属性特性。当我们想要同时设置多个属性的特性时，需要使用我们之前提到过的Object.defineProperties</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'Jake'</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> this.value || 22</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">      this.value = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.name // Jake</span><br><span class="line">person.age // 22</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性值"><a href="#读取属性的特性值" class="headerlink" title="读取属性的特性值"></a>读取属性的特性值</h3><blockquote><p>我们可以使用Object.getOwnPropertyDescriptor方法读取某一个属性的特性值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  value: <span class="string">'alex'</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var descripter = Object.getOwnPropertyDescriptor(person, <span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line">console.log(descripter) // 返回结果如下</span><br><span class="line"></span><br><span class="line">descripter = &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'alex'</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>关于面向对象的基础知识大概就是这些了。我从最简单的创建一个对象开始，解释了为什么我们需要构造函数与原型，理解了这其中的细节，有助于我们在实际开发中灵活的组织自己的对象。因为我们并不是所有的场景都会使用构造函数或者原型来创建对象，也许我们需要的对象并不会声明多个实例，或者不用区分对象的类型，那么我们就可以选择更简单的方式。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;总结了一下我学习前端以来我遇到了哪些瓶颈，那么面向对象一定是第一个想到的。尽管现在对于面向对象有了一些了解，但是那种似懂非懂的感觉，依然历历在目。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="面向对象" scheme="https://www.chenkl.vip/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="构造函数" scheme="https://www.chenkl.vip/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="原型" scheme="https://www.chenkl.vip/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://www.chenkl.vip/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(九)--深入详解函数的柯里化</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B9%9D)--%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B9%9D)--%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2020-08-09T14:20:04.000Z</published>
    <updated>2020-08-09T07:26:33.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>柯里化是函数的一个高级应用，我们知道，接收函数作为参数的函数，都可以叫做高阶函数。我们常常利用高阶函数来封装一些公共的逻辑。这里的柯里化，其实就是高阶函数的一种特殊用法。</p></blockquote><a id="more"></a><div class="note info">            <p>柯里化是指这样一个函数（假设叫做createCurry），他接收函数A作为参数，运行后能够返回一个新的函数，并且这个新的函数能够处理函数A的剩余参数。</p>          </div><blockquote><p>如：有一个接收三个参数的函数A</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> A(a, b, c) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加入，我们有一个已经封装好了的柯里化通用函数createCurry。他接收bar作为参数，能够将A转化为柯里化函数，返回结果就是这个被转化之后的函数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var _A = createCurry(A)</span><br></pre></td></tr></table></figure><blockquote><p>那么_A作为createCurry运行的返回函数，他能够处理A的剩余参数，因此下面的运行结果都是等价的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_A(1, 2, 3)</span><br><span class="line">_A(1, 2)(3)</span><br><span class="line">_A(1)(2, 3)</span><br><span class="line">_A(1)(2)(3)</span><br><span class="line">A(1, 2, 3)</span><br></pre></td></tr></table></figure><blockquote><p>函数A被createCurry转化之后得到柯里化函数_A，_A能够处理A的所有剩余参数。因此柯里化也被称为部分求值。</p></blockquote><blockquote><p>在简单的场景下，可以不用借助柯里化通用式来转化得到柯里化函数，我们凭借眼里自己封装。</p></blockquote><blockquote><p>例如有一个简单的加法函数，他能够将自身的三个参数加起来并返回计算结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(a, b, c) &#123;</span><br><span class="line">  <span class="built_in">return</span> a + b + c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么add函数的柯里化函数_add则可以如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> _add(a) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(b) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(c) &#123;</span><br><span class="line">      <span class="built_in">return</span> a + b + c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面的运算方式是等价的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(1, 2, 3)</span><br><span class="line">_add(1)(2)(3)</span><br></pre></td></tr></table></figure><blockquote><p>当然，靠眼里封装的柯里化函数自由度偏低，柯里化通用式具备更加强大的能力。因此我们需要知道如何去封装这样一个柯里化的通用式。</p></blockquote><blockquote><p>首先通过_add可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数收集起来，并最里层里面处理。在实现createCurry时，可以借助这个思路来进行封装。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 简单实现，参数只能从右到左传递</span><br><span class="line"><span class="keyword">function</span> createCurry(func, args) &#123;</span><br><span class="line">  var arity = func.length</span><br><span class="line">  var args = args || []</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var _args = [].slice.call(arguments)</span><br><span class="line">    [].push.apply(_args, args)</span><br><span class="line">    </span><br><span class="line">    // 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span><br><span class="line">    <span class="keyword">if</span> (_args.length &lt; arity) &#123;</span><br><span class="line">      <span class="built_in">return</span> createCCurry.call(this, func, _args)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 参数收集完毕，则执行func</span><br><span class="line">    <span class="built_in">return</span> func.apply(this, _args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个createCurry函数的封装借助闭包与递归，实现了一个参数的收集，并在收集完毕之后执行所有参数的一个过程。</p></blockquote><blockquote><p>我们会发现，把函数经过createCurry转化为一个柯里化函数，最后执行结果，不是正好相当于执行函数自身吗？柯里化是不是把简单的问题复杂化了？</p></blockquote><blockquote><p>柯里化确实是把简单的问题复杂化了，但是复杂化的同时，我们使用函数拥有了更加多的自由度。而这里对于函数参数的自由处理，正式柯里化的核心所在。</p></blockquote><blockquote><p>如：如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> checkPhone(phoneNumber) &#123;</span><br><span class="line">  <span class="built_in">return</span> /^1[34578]\d&#123;9&#125;$/.<span class="built_in">test</span>(phoneNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>而如果想要验证是否是邮箱呢？这么封装：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> checkEmail(email) &#123;</span><br><span class="line">  <span class="built_in">return</span> /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/.<span class="built_in">test</span>(email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实战中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> check(targetString, reg) &#123;</span><br><span class="line">  <span class="built_in">return</span> reg.test(targetString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是这样封装之后，在使用时又稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下。这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var _check = createCurry(check)</span><br><span class="line"></span><br><span class="line">var checkPhone = _check(/^1[34578]\d&#123;9&#125;$/)</span><br><span class="line">var checkEmail = _check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/)</span><br></pre></td></tr></table></figure><blockquote><p>最后在使用的时候就会变得更加直观与简洁了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkPhone(<span class="string">'183888888'</span>)</span><br><span class="line">checkEmail(<span class="string">'xxxxx@test.com'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>继续来思考一个例子。这个例子与map有关。我们之前分析了封装map方法的思考过程。由于我们没有办法确认一个数组在遍历时会执行什么操作，因此我们只能将调用for循环的这个统一逻辑封装起来，而具体的操作则通过参数传入的形式让使用者自定义。这就是map函数。</p></blockquote><blockquote><p>实践中我们常常会发现，在我们的某个项目中，针对某一个数组的操作其实是固定的，也就是说，同样的操作，可能会在项目的不同地方调用很多次。</p></blockquote><blockquote><p>于是，这个时候哦，我们就可以在map函数的基础上，进行二次封装，以简化我们在项目中使用。假如这个在我们项目中会调用多次的操作是将数组的每一项都转为百分比1 –&gt; 100%。</p></blockquote><blockquote><p>普通思维下我们可以这样封装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getNewArray(array) &#123;</span><br><span class="line">  <span class="built_in">return</span> array.map(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">    <span class="built_in">return</span> item * 100 + <span class="string">'%'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNewArray([1, 2, 3, 0.12]) // [<span class="string">'100%'</span>, <span class="string">'200%'</span>, <span class="string">'300%'</span>, <span class="string">'12%'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>而如果借助柯里化来二次封装这样的逻辑，则会如下实现：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> _map(func, array) &#123;</span><br><span class="line">  <span class="built_in">return</span> array.map(func)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _getNewArray  = createCurry(_map)</span><br><span class="line"></span><br><span class="line">var getNewArray = _getNewArray(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">  <span class="built_in">return</span> item * 100 + <span class="string">'%'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">getNewArray([1, 2, 3, 0.12]) // [<span class="string">'100%'</span>, <span class="string">'200%'</span>, <span class="string">'300%'</span>, <span class="string">'12%'</span>]</span><br><span class="line">getNewArray([0.01, 1]) // [<span class="string">'1%'</span>, <span class="string">'100%'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> _filter(func, array) &#123;</span><br><span class="line">  <span class="built_in">return</span> array.filter(func)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _find = createCurry(_filter)</span><br><span class="line"></span><br><span class="line">var findNumber = _find(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof item === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">findNumber([1, 2, 3, <span class="string">'2'</span>, <span class="string">'3'</span>, 4]) // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 当我们继续封装另外的过滤操作时就会变得更加简单</span><br><span class="line">// 找出数字为20的子项</span><br><span class="line">var find20 = _find(<span class="keyword">function</span>(item, i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof item === 20) &#123;</span><br><span class="line">    <span class="built_in">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">find20([1, 2, 3, 30, 20, 100]) // 4</span><br><span class="line"></span><br><span class="line">// 找出数组中大于100的所有数据</span><br><span class="line">var findGreater100  = _find(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; 100) &#123;</span><br><span class="line">    <span class="built_in">return</span> item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">findGreater100([1, 2, 101, 300, 2, 122]) // [101, 300, 122]</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>其实并不建议在任何情况下以炫技为目的去使用柯里化，在了柯里化的实现中，我们知道柯里化虽然具有了更多的自由度，但是同时柯里化通用式里调用了arguments对象，使用了递归与闭包，因此柯里化的自由度是以牺牲了一定的性能为代价换来的，只有在情况变得更复杂时，才是柯里化大显身手的时候。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;柯里化是函数的一个高级应用，我们知道，接收函数作为参数的函数，都可以叫做高阶函数。我们常常利用高阶函数来封装一些公共的逻辑。这里的柯里化，其实就是高阶函数的一种特殊用法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="函数的柯里化" scheme="https://www.chenkl.vip/tags/%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(八)--函数与函数式编程</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%85%AB)--%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%85%AB)--%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2020-07-27T09:45:01.000Z</published>
    <updated>2020-08-22T02:51:57.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象所有的重点难点，几乎都与函数息息相关。</p></blockquote><a id="more"></a><h2 id="函数声明、函数表达式、匿名函数与自执行函数"><a href="#函数声明、函数表达式、匿名函数与自执行函数" class="headerlink" title="函数声明、函数表达式、匿名函数与自执行函数"></a>函数声明、函数表达式、匿名函数与自执行函数</h2><blockquote><p>关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。</p></blockquote><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><blockquote><p>在JavaScript中，有两种声明方式，一个是使用<code>var/let/const</code>的变量声明，另一个是使用<code>function</code>的函数声明。</p></blockquote><blockquote><p>我们知道，变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明函数，都可以在同一个执行上下文中直接使用该函数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><blockquote><p>与函数声明不同，函数表达式使用了<code>var/let/const</code>进行声明，那么我们在确认他是否可以正确使用的时候就必须依照<code>var/let/const</code>的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两步操作。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明</span><br><span class="line">var a = 20</span><br><span class="line"></span><br><span class="line">// 实际执行顺序</span><br><span class="line">var a = undefined // 变量声明，初始值undefined，变量提升，提升顺序次于<span class="keyword">function</span>声明</span><br><span class="line">a = 20 // 变量赋值，该操作不会提升</span><br></pre></td></tr></table></figure><blockquote><p>同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn() // 报错</span><br><span class="line"></span><br><span class="line">var fn = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例的执行顺序为：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn = undefined // 变量提升</span><br><span class="line"></span><br><span class="line">fn() // 执行报错</span><br><span class="line"></span><br><span class="line">fn = <span class="function"><span class="title">function</span></span>() &#123; // 赋值操作，此时将后边函数的引用赋值给fn</span><br><span class="line">  console.log(<span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。</p>          </div><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另外一个函数中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line">var fn = <span class="keyword">function</span>(bar, num) &#123;</span><br><span class="line">  <span class="built_in">return</span> bar() + num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> a</span><br><span class="line">&#125;, 20)</span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 变量对象在fn上下文执行过程中的创建阶段</span><br><span class="line">OV(fn) = &#123;</span><br><span class="line">  arguments: &#123;</span><br><span class="line">    bar: undefined,</span><br><span class="line">    num: undefined,</span><br><span class="line">    length: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 变量对象在fn上下文执行过程中的执行阶段</span><br><span class="line">// 变量对象变为活跃对象，并完成赋值操作与执行可执行代码</span><br><span class="line">VO -&gt; AO</span><br><span class="line"></span><br><span class="line">AO(fn) = &#123;</span><br><span class="line">  arguments: &#123;</span><br><span class="line">    bar: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> a &#125;,</span><br><span class="line">    num: 20,</span><br><span class="line">    length: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也尝尝称这个匿名函数为回调函数。</p></blockquote><h2 id="函数自执行与块级作用域"><a href="#函数自执行与块级作用域" class="headerlink" title="函数自执行与块级作用域"></a>函数自执行与块级作用域</h2><blockquote><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而函数自执行，其实是匿名函数的一种应用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p></blockquote><blockquote><p>根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // 私有变量</span><br><span class="line">  var age = 20</span><br><span class="line">  var name = <span class="string">'haha'</span></span><br><span class="line">  </span><br><span class="line">  // 私有方法</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'your name is '</span> + name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>但是公有方法和变量应该怎么办？我们可以利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // 私有变量</span><br><span class="line">  var age = 20</span><br><span class="line">  var name = <span class="string">'haha'</span></span><br><span class="line">  </span><br><span class="line">  // 私有方法</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'your name is '</span> + name</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 公有方法</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">getAge</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 讲引用保存在外部执行环境的变量，形成闭包，防止该执行环境被垃圾回收</span><br><span class="line">  window.getAge = getAge</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>为了进一步了解闭包，我们来看看jQuery中，是如何利用模块与闭包的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 使用函数自执行的方式创建模块</span><br><span class="line">(<span class="keyword">function</span>(window, undefined) &#123;</span><br><span class="line">  </span><br><span class="line">  // 声明jQuery构造函数</span><br><span class="line">  var jQuery = <span class="keyword">function</span>(name) &#123;</span><br><span class="line">    </span><br><span class="line">    // 主动在构造函数中，返回一个jQuery实例</span><br><span class="line">    <span class="built_in">return</span> new jQuery.fn.init(name)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 添加原型方法</span><br><span class="line">  jQuery.prototype = jQuery.fn = &#123;</span><br><span class="line">    constructor: jQuery,</span><br><span class="line">    init: <span class="function"><span class="title">function</span></span>() &#123;...&#125;,</span><br><span class="line">    css: <span class="function"><span class="title">function</span></span>() &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  jQuery.fn.init.prototype = jQuery.fn</span><br><span class="line">  </span><br><span class="line">  // 将jQuery改名为$，并将引用保存在window，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了。</span><br><span class="line">  window.jQuery = window.$ = jQuery</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 在使用时，直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候自己new一个实例了。</span><br><span class="line">$(<span class="string">'#div'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>接下来，我们来看下一个高级的，非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，一个叫做状态管理器的东西就应运而生了。对于状态管理器，最出名的，非redux莫属了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// 自执行创建模块</span><br><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // states 结构预览</span><br><span class="line">  // states = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    m: 30,</span><br><span class="line">    o: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var states = &#123;&#125; // 私有变量，用来存储状态与数据</span><br><span class="line">  </span><br><span class="line">  // 判断数据类型</span><br><span class="line">  <span class="keyword">function</span> <span class="built_in">type</span>(elem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elem === null) &#123;</span><br><span class="line">      <span class="built_in">return</span> elem + <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> toString.call(elem).replace(/[\[\]]/g, <span class="string">''</span>).split(<span class="string">' '</span>)[1].toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * @Param name 属性名</span><br><span class="line">   * @Description 通过属性名获取保存在states中的值</span><br><span class="line">   */</span><br><span class="line">  <span class="keyword">function</span> get(name) &#123;</span><br><span class="line">    <span class="built_in">return</span> states[name] ? states[name] : <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">getStates</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> states</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">   * @param options &#123;object&#125; 键值对</span><br><span class="line">   * @param target &#123;object&#125; 属性值为对象的属性，只在函数实现时递归中传入</span><br><span class="line">   * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似</span><br><span class="line">  */</span><br><span class="line">  <span class="keyword">function</span> <span class="built_in">set</span>(options, target) &#123;</span><br><span class="line">    var keys = Object.keys(options)</span><br><span class="line">    var o = target ? target : states</span><br><span class="line">    </span><br><span class="line">    keys.map(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">      <span class="keyword">if</span> (typeof o[item] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        o[item] = options[item]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">type</span>(o[item]) === <span class="string">'object'</span> ? <span class="built_in">set</span>(options[item], o[item]) : o[item] = options[item]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 对外提供接口</span><br><span class="line">  window.get = get</span><br><span class="line">  window.set = <span class="built_in">set</span></span><br><span class="line">  window.getStates = getStates</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 具体使用如下</span><br><span class="line"><span class="built_in">set</span>(&#123; a: 20 &#125;) // 保存属性a</span><br><span class="line"><span class="built_in">set</span>(&#123; b: 100 &#125;) // 保存属性b</span><br><span class="line"><span class="built_in">set</span>(&#123; c: 10 &#125;) // 保存属性c</span><br><span class="line"></span><br><span class="line">// 保存属性o，它的值为一个对象</span><br><span class="line"><span class="built_in">set</span>(&#123;</span><br><span class="line">  o: &#123;</span><br><span class="line">    m: 10,</span><br><span class="line">    n: 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 修改对象</span><br><span class="line"><span class="built_in">set</span>(&#123;</span><br><span class="line">  o: &#123;</span><br><span class="line">    m: 1000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 给对象o中增加一个c属性</span><br><span class="line"><span class="built_in">set</span>(&#123;</span><br><span class="line">  o: &#123;</span><br><span class="line">    c: 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(getStates())</span><br></pre></td></tr></table></figure><h2 id="函数参数传递方式：按值传递"><a href="#函数参数传递方式：按值传递" class="headerlink" title="函数参数传递方式：按值传递"></a>函数参数传递方式：按值传递</h2><blockquote><p>基本数据类型复制，是值直接发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line">var b = a</span><br><span class="line">b = 10</span><br><span class="line">console.log(a) // 20</span><br><span class="line"></span><br><span class="line">var m = &#123; a: 1, b: 2 &#125;</span><br><span class="line">var n = m</span><br><span class="line">n.a = 5</span><br><span class="line">console.log(m.a) // 5</span><br></pre></td></tr></table></figure><blockquote><p>当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(a) &#123;</span><br><span class="line">  a = a + 10</span><br><span class="line">  <span class="built_in">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(a)</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; m: 10, n: 20 &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fn(a) &#123;</span><br><span class="line">  a.m = 20</span><br><span class="line">  <span class="built_in">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(a)</span><br><span class="line">console.log(a) // &#123; m: 20, n: 20 &#125;</span><br></pre></td></tr></table></figure><blockquote><p>正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用保存在变量对象中的引用而已。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fucntion setName(obj) &#123; // 传入一个引用</span><br><span class="line">  obj = &#123;&#125; // 将传入的引用指向另外的值</span><br><span class="line">  obj.name = <span class="string">'heihei'</span> // 修改引用的name属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setName(person)</span><br><span class="line">console.log(person.name) // haha未被改变</span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为heihei的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。</p></blockquote><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote><p>虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加的了解自己写的代码。</p></blockquote><blockquote><p>当我们想要使用一个函数时，通常情况下其实就是想要将一些功能，逻辑等封装起来。我们通常通过函数封装来完成一件事情，例如：想要计算任意三个数的和。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(a, b, c) &#123;</span><br><span class="line">  <span class="built_in">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1 ,2, 3) //6</span><br></pre></td></tr></table></figure><blockquote><p>当然，当想要做的事情比较简单时，可能还看不出来封装成为函数之后带来的便利。如果我们想要做的事情稍微复杂一点呢。例如我想要计算一个数组中的所有子项目中的和。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mergeArr(arr) &#123;</span><br><span class="line">  var result = 0</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    result += arr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不通过函数封装的方式，那么再每次想要实现这个功能时，就不得不重新使用一次for循环，这样的后果就是我们代码充斥着越来越多重复代码。而封装之后，当我们想要再次做这个事情的时候，只需要调用就可以了。</p></blockquote><blockquote><p>当我们想要去封装一个函数时，如果做才是最佳实践？</p></blockquote><blockquote><p>我们在初学时，往往会不由自主的使用命令式编程的风格来完成我们想要干的事情。因为命令式变成更加简单，直白。例如我们现在有一个数组，<code>array = [1, 3, &#39;h&#39;, 5, &#39;m&#39;, &#39;4&#39;]</code>，现在想要找出这个数组中的所有类型为number的子项。当我们使用命令式变成思维时，可能就会直接这样做。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 3, <span class="string">'h'</span>, 5, <span class="string">'m'</span>, <span class="string">'4'</span>]</span><br><span class="line">var res = []</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; array.length; i ++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof array[i] === <span class="string">'number'</span>) &#123;</span><br><span class="line">    res.push(array[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种实现方式中，我们平铺直叙的实现了我们的目的。这样做的问题在于，当我们在另外的时刻，想要找出另外一个数组中所有的子项时，我们不得不把同样的逻辑再写一次。当出现次数变多时，我们的代码也变得更加糟糕且难以维护。</p></blockquote><blockquote><p>而函数式变成的思想则建议我们将这种会多次出现的功能封装起来以备用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getNumbers(array) &#123;</span><br><span class="line">  var res = []</span><br><span class="line">  array.forEach(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof item === <span class="string">'number'</span>) &#123;</span><br><span class="line">      res.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以上是我们的封装，以下是功能实现</span><br><span class="line">var array = [1, 3, <span class="string">'h'</span>, 5, <span class="string">'m'</span>, <span class="string">'4'</span>]</span><br><span class="line">var res = getNumbers(array)</span><br></pre></td></tr></table></figure><blockquote><p>函数式变成思维还具有以下几个特征</p></blockquote><ul><li>函数是第一等公民</li></ul><blockquote><p>指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125; // 赋值</span><br><span class="line"><span class="keyword">function</span> fn(<span class="function"><span class="title">function</span></span>() &#123;&#125;, num) &#123;&#125; // 函数作为参数</span><br><span class="line"></span><br><span class="line">// 函数作为返回值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">var</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只用表达式，不用语句</li></ul><blockquote><p>表达式是一个单纯的运算过程，总是有返回值；语句是执行某种操作，没有返回值。函数式变成要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p></blockquote><blockquote><p>假设我们写项目中，多处需要改变某个元素的背景色，我们可以这样封装下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ele = doucument.querySelector(<span class="string">'.test'</span>)</span><br><span class="line"><span class="keyword">function</span> setBackgroundColor(color) &#123;</span><br><span class="line">  ele.style.backgroundColor = color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多处使用</span><br><span class="line">setBackgroundColor(<span class="string">'red'</span>)</span><br><span class="line">setBackgroundColor(<span class="string">'#ccc'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>我们可以很明显的感受到，setBackgroundColor封装的仅仅只是一条语句。这并不是理想的效果。函数式变成期望一个函数有输入，也有输出。因此良好的习惯应该如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> setBackgroundColor(ele, color) &#123;</span><br><span class="line">  ele.style.backgroundColor = color</span><br><span class="line">  <span class="built_in">return</span> color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多处使用</span><br><span class="line">var ele = document.querySelector(<span class="string">'.test'</span>)</span><br><span class="line">setBackgroundColor(ele, <span class="string">'red'</span>)</span><br><span class="line">setBackgroundColor(ele, <span class="string">'#ccc'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。</p></blockquote><ul><li>纯函数</li></ul><blockquote><p>想同的输入总会得到相同的输出，并且不会产生副作用的函数，就是纯函数</p></blockquote><blockquote><p>所谓副作用，指的是函数内部与外部互动(最典型的情况，就是修改全局变量的值)，产生运算意外的其他结果。</p></blockquote><blockquote><p>函数式变成强调没有副作用，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不的修改外部变量的值。即：<code>只要是同样的参数传入，返回的结果一定是相等的</code>。</p></blockquote><blockquote><p>例如我们期望封装一个函数，能够得到传入数组的最后一项。那么可以通过下面两种方式来实现。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getLast(arr) &#123;</span><br><span class="line">  <span class="built_in">return</span> arr[arr.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> getLast_(arr) &#123;</span><br><span class="line">  retrun arr.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="built_in">source</span> = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var last = getLast(<span class="built_in">source</span>) // 返回结果4 原数组不变</span><br><span class="line">var last_ = getLast_(<span class="built_in">source</span>) // 返回结果4 原数据最后一项被删除</span><br></pre></td></tr></table></figure><blockquote><p>getLast与getLast_虽然同样能够获得数组的最后一项值，但是getLast_改变了原数组。而当原始数组被改变，那么当我们再次调用该方法时，得到的结果就会变得不一样。这样不可预测的封装方式，在我们看来是非常糟糕的。它会把我们的数据搞得非常混乱。在JavaScript原生支持的数据方法中，也有许多不纯的方法，我们在使用时需要非常警惕，我们要清晰的知道原始数据的改变是否会留下隐患。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">source</span> = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">sourec.slice(1, 3) // 纯函数 返回[2, 3] <span class="built_in">source</span>不变</span><br><span class="line">source.splice(1, 3) // 不纯的 返回[2, 3, 4] <span class="built_in">source</span>被改变</span><br><span class="line"></span><br><span class="line">source.pop() // 不纯的</span><br><span class="line">source.push(6) // 不纯的</span><br><span class="line">source.shift() // 不纯的</span><br><span class="line">source.unshift(1) // 不纯的</span><br><span class="line">source.reverse() // 不纯的</span><br><span class="line"></span><br><span class="line">// 我也不能短时间知道现在<span class="built_in">source</span>被改变成了什么样子，干脆重新约定一下</span><br><span class="line"><span class="built_in">source</span> = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">source.concat([6, 7]) // 纯函数 返回[1, 2, 3, 4, 5, 6, 7] <span class="built_in">source</span>不变</span><br><span class="line">source.join(<span class="string">'-'</span>) // 纯函数 返回1-2-3-4-5 <span class="built_in">source</span>不变</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在学习过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象所有的重点难点，几乎都与函数息息相关。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="函数与函数式编程" scheme="https://www.chenkl.vip/tags/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(七)--this</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%83)--this/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%83)--this/</id>
    <published>2020-07-26T15:21:29.000Z</published>
    <updated>2020-08-22T02:52:17.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。比如对于<code>this</code>指向理解中，有一种说法：谁调用它，<code>this</code>就指向谁。</p></blockquote><a id="more"></a><blockquote><p>我们回顾一下执行上下文</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720164300.png" alt=""></p><blockquote><p>执行上下文的创建阶段，会分别生成变量对象，建立作用于，确定<code>this</code>指向。其中变量对象与作用于链我们都已经明白了。本文的关键，就是确定<code>this</code>指向。</p></blockquote><blockquote><p>首先，我们需要得出一个非常重要的，并且一定要牢记于心的结论，<code>this的指向，是在函数被调用的时候确定的</code>。也就是执行上下文被创建时确定的。</p></blockquote><blockquote><p>因此，一个函数中的<code>this</code>指向，可以非常灵活。比如下面的例子中，同一个函数由于调用的方式不同，<code>this</code>指向了不一样的对象。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn() // 10</span><br><span class="line">fn.call(obj) // 20</span><br></pre></td></tr></table></figure><blockquote><p>除此之外，<code>在函数执行过程中，this一旦被确定，就不可更改了。</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  this = obj // 这句话试图修改this，运行后会报错</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><h2 id="全局对象中的this"><a href="#全局对象中的this" class="headerlink" title="全局对象中的this"></a>全局对象中的this</h2><blockquote><p>关于全局对象的<code>this</code>，它是一个比较特殊的存在。全局环境中的<code>this</code>，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 通过this绑定到全局对象</span><br><span class="line">this.a2 = 20</span><br><span class="line"></span><br><span class="line">// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span><br><span class="line">// var a1 = 10</span><br><span class="line"></span><br><span class="line">// 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span><br><span class="line">a3 = 10</span><br><span class="line"></span><br><span class="line">// 输出结果会全部符合预期</span><br><span class="line">console.log(a1)</span><br><span class="line">console.log(a2)</span><br><span class="line">console.log(a3)</span><br></pre></td></tr></table></figure><h2 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h2><blockquote><p>我们有必要通过一些奇怪的例子，来感受一下函数中<code>this</code>的捉摸不定。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line"></span><br><span class="line">var a = 20</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// demo02</span><br><span class="line"></span><br><span class="line">var a = 20</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">  &#125;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// demo03</span><br><span class="line"></span><br><span class="line">var a = 20</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  c: this.a + 20,</span><br><span class="line">  fn: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj.c)</span><br><span class="line">console.log(obj.fn())</span><br></pre></td></tr></table></figure><blockquote><p>分析之前，我们直接了当抛出结论</p></blockquote><blockquote><p>在一个函数上下文中，<code>this</code>由调用者提供，由调用函数的方式来决定。<code>如果调用者函数，被一个对象用有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined</code>。但在非严格模式中，当<code>this</code>指向<code>undefined</code>时，它会被自动指向全局对象。</p></blockquote><blockquote><p>想要准确确定<code>this</code>指向，找到函数的调用者以及区分他是否是独立调用十分关键。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 为了能够准确判定，我们在函数内部使用严格模式，因为非严格模式会自动指向全局</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  <span class="string">'use strict'</span></span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">fn() // fn 是调用者，独立调用</span><br><span class="line">window.fn() // fn是调用者，被window所拥有</span><br></pre></td></tr></table></figure><blockquote><p>在上面的简单例子中，<code>fn()</code>作为独立调用者，按照定义的理解，它内部的<code>this</code>指向就是<code>undefined</code>。而<code>window.fn()</code>则因为<code>fn</code>被<code>window</code>所拥有，内部的<code>this</code>就指向了<code>window</code>对象。</p></blockquote><blockquote><p>掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，你就会发现，原来<code>this</code>已经变得不那么虚无缥缈了。</p></blockquote><blockquote><p>但是我们需要特别注意的是<code>demo03</code>，在里面，对象obj中的c属性使用<code>this.a + 20</code>来计算。这里我们需要明确的一点是，单独的{}不会行程新的作用域，因此这里的<code>this.a</code>，由于并没有作用域的限制，它仍然处于全局作用域中，所以这里的<code>this</code>其实是指向的<code>window对象</code>。</p></blockquote><blockquote><p>那么我们修改一下<code>demo03</code>的代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line">var a = 20</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    c: this.a + 20,</span><br><span class="line">    fn: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      <span class="built_in">return</span> this.a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> obj.c</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo()) // ?</span><br><span class="line">console.log(window.foo()) // ?</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在浏览器中看到，控制台直接报错。</p></blockquote><div class="note warning">            <p>实际开发中，并不推荐这样使用this</p><p>上面多次提到的严格模式，需要大家认真对象，因为实际开发中，现在基本上已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式的。</p>          </div><blockquote><p>再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line">var foo = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  getA: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo.getA()) // 10</span><br><span class="line"></span><br><span class="line">var <span class="built_in">test</span> = foo.getA</span><br><span class="line">console.log(<span class="built_in">test</span>()) // 20</span><br></pre></td></tr></table></figure><p><code>foo.getA()</code>中，<code>getA</code>是调用者，他不是独立调用，被对象<code>foo</code>所拥有，因此它的<code>this</code>指向了<code>foo</code>。而<code>test()</code>作为调用者，尽管它与<code>foo.getA</code>的引用相同，但它是独立调用的，因此<code>this</code>指向<code>undefined</code>，在非严格模式下，自动转向全局<code>window</code>。</p><blockquote><p>稍微修改一下代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getA</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  getA: getA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo.getA()) // 10</span><br></pre></td></tr></table></figure><blockquote><p>再来一个例子</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> active(fn) &#123;</span><br><span class="line">  fn() // 真实调用者，为独立调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 20</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  getA: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">active(obj.getA) // 20</span><br></pre></td></tr></table></figure><h2 id="使用call，apply显示指定this"><a href="#使用call，apply显示指定this" class="headerlink" title="使用call，apply显示指定this"></a>使用call，apply显示指定this</h2><blockquote><p>JavaScript内部提供了一种机制，让我们可以自行手动设置<code>this</code>的指向。它们就是<code>call</code>与<code>apply</code>。所有的函数都具有这两个方法。它们除了参数略有不同之外，其功能完全一样。它们的第一个参数都为<code>this</code>将要指向的对象。</p></blockquote><blockquote><p>如下例子所示。<code>fn</code>并非属于对象<code>obj</code>的方法，但是通过<code>call</code>，我们将<code>fn</code>内部的<code>this</code>绑定为<code>obj</code>，因此就可以使用<code>this.a</code>访问<code>obj</code>的a属性。这就是<code>call/apply</code>的用法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  console.log(this.a) // 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj)</span><br></pre></td></tr></table></figure><blockquote><p><code>call</code>与<code>apply</code>后面的参数，都是向将要执行的函数传递参数。其中<code>call</code>以一个一个的形式传递，<code>apply</code>以数组的形式传递。这是他们唯一的不同。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn(num1, num2) &#123;</span><br><span class="line">  console.log(this.a + num1 + num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj, 100, 10) // 130</span><br><span class="line">fn.apply(obj, [20, 10]) // 50</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>call/apply</code>的存在，JavaScript变得更加灵活。也因此他们的使用场景就多种多样。</p></blockquote><h3 id="将类数组对象转为数组"><a href="#将类数组对象转为数组" class="headerlink" title="将类数组对象转为数组"></a>将类数组对象转为数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> exam(a, b, c, d, e) &#123;</span><br><span class="line">  // 先看看函数的自带属性 arguments 什么是样子的</span><br><span class="line">  console.log(arguments)</span><br><span class="line">  </span><br><span class="line">  // 使用call/apply将arguments转为数组，返回结果为数组，arguments自身不会改变</span><br><span class="line">  var arg = [].slice.call(arguments)</span><br><span class="line">  </span><br><span class="line">  console.log(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exam(2, 8, 9, 10, 3)</span><br><span class="line"></span><br><span class="line">/ result:</span><br><span class="line">// &#123; <span class="string">'0'</span>: 2, <span class="string">'1'</span>: 8, <span class="string">'2'</span>: 9, <span class="string">'3'</span>: 10, <span class="string">'4'</span>: 3 &#125;</span><br><span class="line">// [ 2, 8, 9, 10, 3 ]</span><br><span class="line"></span><br><span class="line">// 也常常使用该方法将DOM中的nodelist转换为数组</span><br><span class="line">// [].slice.call(document.getElementsByTagName(<span class="string">'li'</span>))</span><br></pre></td></tr></table></figure><h3 id="根据自己的需要灵活修改this指向"><a href="#根据自己的需要灵活修改this指向" class="headerlink" title="根据自己的需要灵活修改this指向"></a>根据自己的需要灵活修改this指向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  showName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = &#123;</span><br><span class="line">  name: <span class="string">'hehe'</span></span><br><span class="line">&#125;</span><br><span class="line">foo.showName.call(bar)</span><br></pre></td></tr></table></figure><h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义父级的构造函数</span><br><span class="line">var Person = <span class="keyword">function</span>(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义子类的构造函数</span><br><span class="line">var Student = <span class="keyword">function</span>(name, age, high) &#123;</span><br><span class="line">  // use call</span><br><span class="line">  Person.call(this, name, age)</span><br><span class="line">  this.high = high</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'name:'</span> + this.name + <span class="string">', age:'</span> + this.age + <span class="string">', high:'</span> + this.high + <span class="string">', gender:'</span> + this.gender[0] + <span class="string">';'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Student(<span class="string">'xiaoming'</span>, 12, <span class="string">'180cm'</span>).message() // name:xiaoming, age:12, high:180cm, gender:man;</span><br></pre></td></tr></table></figure><h3 id="在向其他执行上下文的传递中，确保this的指向保持不变"><a href="#在向其他执行上下文的传递中，确保this的指向保持不变" class="headerlink" title="在向其他执行上下文的传递中，确保this的指向保持不变"></a>在向其他执行上下文的传递中，确保this的指向保持不变</h3><blockquote><p>如下面例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  getA: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(this.a)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA()</span><br></pre></td></tr></table></figure><blockquote><p>常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这个办法，但是我们也要借助上面将到的只是，来判断this是否是在传递中被修改了，如果没有被修改，就没有必要这样使用了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  getA: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var self = this</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(self.a)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另外就是借助闭包与apply方法，封装一个bind方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(fn, obj) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> fn.apply(obj, arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  getA: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    setTimeout(<span class="built_in">bind</span>(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(this.a)</span><br><span class="line">    &#125;, this), 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getA()</span><br></pre></td></tr></table></figure><blockquote><p>当然，也可以使用ES5中已经自带的bind方法。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  getA: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      console.log(this.a)</span><br><span class="line">    &#125;.<span class="built_in">bind</span>(this), 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>ES6中也常常使用箭头函数的方式来替代这种方案</p>          </div><h2 id="构造函数与原型方法上的this"><a href="#构造函数与原型方法上的this" class="headerlink" title="构造函数与原型方法上的this"></a>构造函数与原型方法上的this</h2><blockquote><p>在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解到了this。</p></blockquote><blockquote><p>结合下面的例子，几个问题可以思考下。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name, age) &#123;</span><br><span class="line">  // 这里的this指向了谁</span><br><span class="line">  console.log(this)</span><br><span class="line">  </span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // 这里的this又指向了谁</span><br><span class="line">  console.log(this)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面的2个this，是同一个吗，他们是否指向了原型对象</span><br><span class="line"></span><br><span class="line">var p1 = new Person(<span class="string">'哈哈'</span>, 20)</span><br><span class="line">p1.getName()</span><br></pre></td></tr></table></figure><blockquote><p>我们已经知道this是在函数调用过程中确定的，因此，搞明白了new的过程中到底发生了什么就变得十分重要</p></blockquote><blockquote><p>通过new操作符调用构造函数，会经历以下4个阶段</p></blockquote><ol><li>创建一个新的对象</li><li>将构造函数的this指向这个新对象</li><li>指向构造函数的代码，为这个对象添加属性，方法等</li><li>返回新对象</li></ol><blockquote><p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将这个对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象：p1。</p></blockquote><blockquote><p>而原型上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，它被p1所拥有，因此getName中的this，也是指向了p1。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>this的指向是非常重要的，不管是在实际开发中还是面试中，出现的概率都是非常高的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。比如对于&lt;code&gt;this&lt;/code&gt;指向理解中，有一种说法：谁调用它，&lt;code&gt;this&lt;/code&gt;就指向谁。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="this" scheme="https://www.chenkl.vip/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(六)--setTimeout与循环闭包</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%85%AD)--setTimeout%E4%B8%8E%E5%BE%AA%E7%8E%AF%E9%97%AD%E5%8C%85/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%85%AD)--setTimeout%E4%B8%8E%E5%BE%AA%E7%8E%AF%E9%97%AD%E5%8C%85/</id>
    <published>2020-07-26T10:01:43.000Z</published>
    <updated>2020-07-26T02:36:45.748Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>初学<code>setTimeout</code>，我们很容易知道<code>setTimeout</code>有两个参数，第一个参数为一个函数，我们通过该函数定义将要执行的操作。第二个参数为一个时间毫秒数，标识延迟执行的时间。</p></blockquote><a id="more"></a><blockquote><p>每一个<code>setTimeout</code>在执行的时候，会返回一个唯一的ID，我们在使用时，常常会使用一个变量讲这个唯一ID保存起来，用以传入<code>clearTimeout</code>来清除定时器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var timer = setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'setTimeout actions'</span>)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'other actions'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>思考一下，当<code>setTimeout</code>的延迟时间设置为0时，上面的执行顺序会是什么？</p></blockquote><blockquote><p>在浏览器中的console中运行我们很快就能够知道答案。在这里，将会介绍另外一个特殊的<code>队列</code>结构，页面中所有由<code>setTimeout</code>定义的操作，都讲放在同一个队列中一次执行。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200726101242.png" alt=""></p><blockquote><p>而这个队列执行的时间，需要等待到函数调用栈清空之后才执行，即所有可执行代码执行完毕之后，才会开始执行由<code>setTimeout</code>定义的操作。而这些操作进入队列的顺序，则有设定的延迟时间来决定。</p></blockquote><blockquote><p>因此在上面的例子中，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于<code>setTimeout</code>执行这一刻，而是相对于其他代码执行完毕这一刻。所以上面的例子执行结果就非常容易理解了。</p></blockquote><blockquote><p>我们在来看一下一个复杂的例子。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(0)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">var a = 10</span><br><span class="line"></span><br><span class="line">console.log(b)</span><br><span class="line">console.log(fn)</span><br><span class="line"></span><br><span class="line">var b = 20</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'setTimeout 10ms'</span>)</span><br><span class="line">  &#125;, 10)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'setTimeout 20ms'</span>)</span><br><span class="line">&#125;, 20)</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><blockquote><p>执行结果如图所示</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200726102702.png" alt=""></p><blockquote><p>关于<code>setTimeout</code>就暂时介绍到这里，我们可以来看看循环闭包的思考题。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 5; i ++) &#123;</span><br><span class="line">  setTimeout(<span class="keyword">function</span> <span class="function"><span class="title">timer</span></span>() &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们直接这样写，根据<code>setTimeout</code>定义的操作在函数调用栈清空之后才会执行的特点，for循环里定义了5个<code>setTimeout</code>操作。而当这些操作开始执行时，for循环的值，已经先一步变成了6。因此输出结果总为6。而我们想要让输出结果依次执行的话，就必须借助闭包的特性，每次循环时，讲值保存在一个闭包中，当<code>setTimeout</code>中定义的操作执行时，则访问对应闭包保存的值即可。</p></blockquote><blockquote><p>而我们知道在函数中闭包判定的准则，即执行时是否在内部定义的函数中访问了上层作用于的变量。我们需要包裹一层自执行函数为闭包的形成提供条件。</p></blockquote><blockquote><p>因此，我们只需要2个操作就可以完成题目需求，一是使用自执行函数提供闭包条件，二是传入i值并保存在闭包中。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 5; i ++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (i) &#123;</span><br><span class="line">    setTimeout(<span class="keyword">function</span> <span class="function"><span class="title">timer</span></span>() &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">    &#125;, i * 1000)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，也可以在<code>setTimeout</code>的第一个参数处利用闭包。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 5; i ++) &#123;</span><br><span class="line">  setTimeout((<span class="keyword">function</span>(i) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i), i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;初学&lt;code&gt;setTimeout&lt;/code&gt;，我们很容易知道&lt;code&gt;setTimeout&lt;/code&gt;有两个参数，第一个参数为一个函数，我们通过该函数定义将要执行的操作。第二个参数为一个时间毫秒数，标识延迟执行的时间。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="setTimeout与循环闭包" scheme="https://www.chenkl.vip/tags/setTimeout%E4%B8%8E%E5%BE%AA%E7%8E%AF%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(五)--闭包</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%94)--%E9%97%AD%E5%8C%85/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%94)--%E9%97%AD%E5%8C%85/</id>
    <published>2020-07-22T10:18:52.000Z</published>
    <updated>2020-08-22T02:52:27.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前端面试，必问闭包。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个面试者，至少5个会死在闭包上。</p></blockquote><a id="more"></a><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>闭包是一种特殊的对象</p></blockquote><blockquote><p>它由两部分组成。执行上下文（代号A），以及在该执行上下文中创建的函数（代号B）。</p></blockquote><blockquote><p>当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var a = 20</span><br><span class="line">  var b = 30</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，首先有执行上下文<code>foo</code>，在<code>foo</code>中定义了函数<code>bar</code>，而通过对外返回<code>bar</code>的方式让<code>bar</code>得以执行。当<code>bar</code>执行时，访问了<code>foo</code>内部的变量a，b。因此这个时候闭包产生了。</p></blockquote><blockquote><p>在之前，我们总结了JavaScript的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。</p></blockquote><blockquote><p>而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用，其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn = null</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">innerFoo</span></span>() &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  fn = innerFoo // 将 innerFoo 的引用，赋值给全局变量中的fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bar</span></span>() &#123;</span><br><span class="line">  fn() // 此处保留innerFoo的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar() // 2</span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，<code>foo()</code>执行完毕之后，按照常理，其执行环境生命周期会结束，所占北村被垃圾收集器释放。但是用过<code>fn = innerFoo</code>，函数<code>innerFoo</code>的引用别保留了下来，复制给了全局变量<code>fn</code>。这个行为，导致了<code>foo</code>的变量对象也被保留了下来。于是，函数<code>fn</code>在函数<code>bar</code>内部执行时，依然可以访问这个被保留下来的变量对象，所以此刻仍然能够访问到变量a的值。这样，我们就可以称<code>foo</code>为<code>闭包</code>。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200722111606.png" alt=""></p><h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><blockquote><p>闭包有两个非常重要的应用场景，他们分别是<code>模块化</code>和<code>柯里化</code>。</p></blockquote><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><blockquote><p>在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化便是其中很重要的一种。</p></blockquote><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><blockquote><p>模块化是闭包最强大的一个应用场景。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  var a = 10</span><br><span class="line">  var b = 20</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> add(num1, num2) &#123;</span><br><span class="line">    var num1 = !!num1 ? num1 : a</span><br><span class="line">    var num2 = !!num2 ? num2 : b</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> num1 + num2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  window.add = add</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>在上面例子中，使用了函数自执行的方式，创建了一个模块。<code>add</code>是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的<code>this</code>中，因此理解闭包，以及原型链是一个非常重要的事情。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前端面试，必问闭包。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个面试者，至少5个会死在闭包上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="闭包" scheme="https://www.chenkl.vip/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(四)--作用域与作用域链</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%9B%9B)--%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E5%9B%9B)--%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</id>
    <published>2020-07-22T09:18:23.000Z</published>
    <updated>2020-08-22T02:52:45.807Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>作用域与作用域链</code>本应该是一个非常简单的概念，但是很多人又会感到困惑。</p></blockquote><a id="more"></a><h2 id="词法环境（Lexical-Environments）"><a href="#词法环境（Lexical-Environments）" class="headerlink" title="词法环境（Lexical Environments）"></a>词法环境（Lexical Environments）</h2><blockquote><p>官方规范对<code>词法环境</code>的说明是<code>词法环境（Lexical Environments）</code>是一种规范类型，用于根据<code>ECMAScript</code>代码的词法嵌套结构来定义标识符与特定变量和函数的关联。（讲道理。。太复杂专业了）</p></blockquote><blockquote><p>简单的来说，<code>词法环境</code>就是一套约定好的规则。我们写代码，应该按照这个规则来。JavaScript引擎对JavaScript码进行词法分析，也是按照这个规则来。</p></blockquote><blockquote><p>因此，<code>词法环境</code>，在我们写代码的时候就已经确定了，明白这一点，对于区分<code>词法环境</code>与<code>执行上下文</code>有非常关键的意义。</p></blockquote><div class="note info">            <p>词法环境，其实就是作用域，有的人叫词法作用域等等。</p>          </div><blockquote><p>因此，我们可以得出以下结论：</p></blockquote><ol><li>在JavaScript中，我们可以将作用域定义为一套规则，这套规则用来管理JavaScript引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。<code>（这里的标识符，指的是变量名或者函数名）</code></li><li>JavaScript中有全局作用域与函数作用域（因为eval我们平时开发中几乎不会用到它，这里不讨论）</li></ol><blockquote><p>除此之外，一个词法环境，由<code>环境记录(Environment Records)</code>与一个外部指向<code>outer</code>组成。</p></blockquote><blockquote><p>环境记录如果非要细分的话，又可以分为<code>函数环境记录</code>与<code>声明性的环境记录</code>，<code>环境记录</code>对应的其实就是<code>变量对象</code>，<code>outer</code>对应的就是上文中出现过，但是没有引起重视的<code>scopeChain</code>。</p></blockquote><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><p>首先，我们要明确一点，作用域和作用域链是不同的。作用域是一套规则，而作用域链则是在代码执行过程中，会动态变化的一条索引路径。</p></blockquote><blockquote><p>我们知道函数在调用激活时，会开始创建对应<code>执行上下文</code>，在执行上下文生成的过程中，<code>变量对象</code>，<code>作用域链</code>，以及<code>this</code>的值会被分别确定。</p></blockquote><div class="note info">            <p>作用域链，是当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>          </div><blockquote><p>为了方便大家理解，我们结合一个例子，以及相应的图示来说明。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  var b = a + 10</span><br><span class="line">  </span><br><span class="line">  functuon <span class="function"><span class="title">innerTest</span></span>() &#123;</span><br><span class="line">    var c = 10</span><br><span class="line">    <span class="built_in">return</span> b + c</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> innerTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>()</span><br></pre></td></tr></table></figure><blockquote><p>在上面例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为<code>VO(global)</code>，<code>VO(test)</code>，<code>VO(innerTest)</code>。而<code>innerTest</code>的作用域链，则同时包含了这三个变量对象。所以<code>innerTest</code>的执行上下文可如下表示。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innerTestEC = &#123;</span><br><span class="line">  VO: &#123;...&#125;, // 变量对象</span><br><span class="line">  scopeChain: [VO(innerTest), VO(<span class="built_in">test</span>), VO(global)] // 作用域链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用一个数组来模拟作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200722095813.png" alt=""></p><div class="note warning">            <p>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，所以使用了AO来表示。</p>          </div><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>作用域链是由一些列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样，就能访问到上一层作用域的变量了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;作用域与作用域链&lt;/code&gt;本应该是一个非常简单的概念，但是很多人又会感到困惑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="作用域与作用域链" scheme="https://www.chenkl.vip/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(三)--变量对象</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%89)--%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%89)--%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-07-20T16:38:52.000Z</published>
    <updated>2020-08-22T02:52:57.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在JavaScript中，肯定不可避免的需要声明变量和函数，JavaScript编译器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。</p></blockquote><a id="more"></a><blockquote><p>我们知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。一个执行上下文的生命周期可以分为两个阶段。</p></blockquote><ul><li>创建阶段</li></ul><blockquote><p>在这个阶段中，执行上下文会分别创建<code>变量对象</code>，建立<code>作用域链</code>，以及确定<code>this</code>指向。</p></blockquote><ul><li>代码执行阶段</li></ul><blockquote><p>创建完之后，就会开始执行代码，会完成变量赋值，函数引用，以及执行其他代码。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720164300.png" alt=""></p><blockquote><p>从这里我们可以详细的了解执行上下文的重要性，因为其中涉及到了<code>变量对象</code>，<code>作用域链</code>，<code>this</code>等很多极为重要的概念。</p></blockquote><h2 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h2><blockquote><p>变量对象的创建，依次经历了几下几个过程。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 这里a为属性名，20是属性值</span><br><span class="line">&#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>建立<code>arguments</code>对象：检查当前上下文中的参数，建立该对象下的属性与属性值。</li><li>检查当前上下文的函数声明，也就是使用<code>function</code>关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。</li><li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为<code>undefined</code></li></ol><div class="note warning">            <p>注意：如果变量与函数同名，则在这个阶段，以函数值为准</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo) // ƒ <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line">var foo = 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 上面的执行顺序为：</span><br><span class="line"></span><br><span class="line">// 首先将所有函数声明放入变量对象中</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，此时以函数值为准，而不会被undefined覆盖</span><br><span class="line">// var foo = undefined</span><br><span class="line"></span><br><span class="line">// 然后开始执行阶段代码的执行</span><br><span class="line">console.log(foo) // ƒ <span class="function"><span class="title">foo</span></span>() &#123; console.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line">foo = 200</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720165744.png" alt=""></p><blockquote><p>根据这个规则，理解变量提升就变得十分简单了，在上面规则中我们可以看出，<code>function</code>声明会比<code>var</code>声明优先级更高一点，为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// demo01</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">  console.log(foo())</span><br><span class="line">  </span><br><span class="line">  var a = 1</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>()</span><br></pre></td></tr></table></figure><blockquote><p>在上例中，我们直接从<code>test()</code>的执行上下文开始理解，全局作用域中运行<code>test()</code>时，<code>test()</code>的执行上下文开始创建，为了方便理解，我们用如下的形式来表示：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建过程</span><br><span class="line">testEC = &#123;</span><br><span class="line">  // 变量对象</span><br><span class="line">  VO: &#123;&#125;,</span><br><span class="line">  </span><br><span class="line">  // 作用域链</span><br><span class="line">  scopeChain: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为本文暂时不想起解释作用域链，所以把变量对象专门提出来说明</span><br><span class="line"></span><br><span class="line">// VO 为 Variable Object的缩写，即变量对象</span><br><span class="line">VO = &#123;</span><br><span class="line">  arguments: &#123;...&#125;, // 注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span><br><span class="line">  foo: &lt;foo reference&gt; // 表示foo的地址引用</span><br><span class="line">  a: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>未进入执行阶段之前，变量对象中的属性都不能访问，但是进入执行阶段之后，<code>变量对象</code>转变为了<code>活动对象</code>，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p></blockquote><div class="note info">            <p>我们可以简单理解，<code>变量对象</code>和<code>活动对象</code>其实都是同一个对象，只是处于执行上下文的不同生命周期，不过只有处于函数调用栈栈顶的执行上下文的<code>变量对象</code>，才会变成<code>活动对象</code>。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 执行阶段</span><br><span class="line">OV -&gt; AO // Active Object</span><br><span class="line"></span><br><span class="line">AO = &#123;</span><br><span class="line">  arguments: &#123;...&#125;,</span><br><span class="line">  foo: &lt;foo reference&gt;,</span><br><span class="line">  a: 1,</span><br><span class="line">  this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因此上面的<code>demo01</code>的执行顺序就变成了这样</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2</span><br><span class="line">  &#125;</span><br><span class="line">  var a</span><br><span class="line">  console.log(a)</span><br><span class="line">  console.log(foo())</span><br><span class="line">  a = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>()</span><br></pre></td></tr></table></figure><blockquote><p>在来一个例子，巩固一下我们的理解</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// demo02</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  console.log(foo)</span><br><span class="line">  console.log(bar)</span><br><span class="line">  </span><br><span class="line">  var foo = <span class="string">'Hello'</span></span><br><span class="line">  console.log(foo)</span><br><span class="line">  var bar = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'world'</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建阶段</span><br><span class="line">VO = &#123;</span><br><span class="line">  arguments: &#123;...&#125;,</span><br><span class="line">  foo: &lt;foo reference&gt;,</span><br><span class="line">  bar: undefined</span><br><span class="line">&#125;</span><br><span class="line">// 这里有一个需要注意的地方，var声明的变量与函数同名，以函数为准</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 执行阶段</span><br><span class="line">VO -&gt; AO</span><br><span class="line"></span><br><span class="line">AO = &#123;</span><br><span class="line">  arguments: &#123;...&#125;,</span><br><span class="line">  foo: <span class="string">'Hello'</span>,</span><br><span class="line">  bar: &lt;bar reference&gt;,</span><br><span class="line">  this: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要结合上面的知识，仔细对比这个例子中的变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。</p></blockquote><h2 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h2><blockquote><p>以浏览器中为例，全局对象为<code>window</code>。</p></blockquote><blockquote><p>全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>对象。而这个特殊，在<code>this</code>指向上也同样使用，<code>this</code>也是指向<code>window</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 以浏览器中为例，全局对象为window</span><br><span class="line">// 全局上下文</span><br><span class="line"></span><br><span class="line">windowEC = &#123;</span><br><span class="line">  VO: window,</span><br><span class="line">  scopeChain: &#123;&#125;,</span><br><span class="line">  this: window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关闭掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p>          </div><h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><blockquote><p><code>ES6</code>中，新增了使用<code>let/const</code>来声明变量。那么，<code>let/const</code>是否存在变量提升呢？</p></blockquote><blockquote><p>我们来做个试验</p></blockquote><ol><li>我们直接使用一个未定义的变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(e) // Uncaught ReferenceError: e is not defined</span><br></pre></td></tr></table></figure><ol start="2"><li>我们在let之前调用变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) // Uncaught ReferenceError: Cannot access <span class="string">'a'</span> before initialization (不能在初始化之前访问a)</span><br><span class="line"><span class="built_in">let</span> a = 10</span><br></pre></td></tr></table></figure><blockquote><p>这个报错说明了，变量定义了，但是没有初始化</p></blockquote><blockquote><p>所以我们可以得出结论：<code>let/const</code>声明的变量，仍然会提前被收集到变量对象中，但和<code>var</code>不同的是，<code>let/const</code>定义的变量，不会再这个时候给它赋值<code>undefined</code>。因为完全没有赋值，即使变量提升了，我们也不能在赋值之前调用它。这就是我们常说的<code>暂时性死区</code>。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>变量提升的现象确实会对我们的代码造成一些负面影响，因此，开发中的好习惯，就是尽量将变量声明放在最前面来写。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在JavaScript中，肯定不可避免的需要声明变量和函数，JavaScript编译器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="变量对象" scheme="https://www.chenkl.vip/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(二)--执行上下文</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)--%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)--%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2020-07-20T11:08:38.000Z</published>
    <updated>2020-08-22T02:53:08.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们在JavaScript学习初期，或者在面试的时候通常会遇到<code>执行上下文</code>相关的思考题，今天，我们就来学习一下什么是<code>执行上下文</code>。</p></blockquote><a id="more"></a><h2 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h2><blockquote><p>每次当控制器转到可执行代码的时候，就会进入一个<code>执行上下文</code>。<code>执行上下文</code>可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况：</p></blockquote><ul><li>全局环境：JavaScript代码运行起来会首先进入该环境</li><li>函数环境：当函数被调用执行时，会进入当前函数执行代码</li><li>eval（不建议使用，可忽略）</li></ul><blockquote><p>因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为<code>函数调用栈(call stack)</code>。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p></blockquote><blockquote><p>当代码在执行过程中，遇到以上三种情况，都会产生一个<code>执行上下文</code>，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。</p></blockquote><div class="note info">            <p>执行上下文可以理解为函数执行的环境，每一个函数执行的时候，都会给对应的函数创建这样一个执行环境。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var color = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">changeColor</span></span>() &#123;</span><br><span class="line">  var anotherColor = <span class="string">'red'</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">swapColors</span></span>() &#123;</span><br><span class="line">    var tempColor = anotherColor</span><br><span class="line">    anotherColor = color</span><br><span class="line">    color = tempColor</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  swapColors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure><blockquote><p>我们用<code>ECStack</code>来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720113015.png" alt=""></p><blockquote><p>全局上下文入栈之后，其中可执行代码开始执行，直到遇到了<code>changeColor()</code>，这一句激活函数<code>changeColor</code>创建它自己的执行上下文，因此第二步就是<code>changeColor</code>的执行上下文入栈。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720135901.png" alt=""></p><blockquote><p><code>changeColor</code>的上下文入栈之后，控制器开始执行其中的可执行代码，遇到<code>swapColors()</code>之后又激活了一个执行上下文。因此第三步是<code>swapColors</code>的执行上下文入栈。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720140128.png" alt=""></p><blockquote><p>在<code>swapColors</code>的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，<code>swapColors</code>的上下文从栈中弹出。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720141357.png" alt=""></p><blockquote><p><code>swapColors</code>的执行上下文弹出之后，继续执行<code>changeColor</code>的可执行代码，也没有在遇到其他执行上下文，顺利执行完毕之后弹出。这样，<code>ECStack</code>中就只剩下全局上下文了。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720113015.png" alt=""></p><blockquote><p>之后，全局上下文在浏览器窗口关闭后出栈。</p></blockquote><div class="note warning">            <p>注意：函数中，遇到<code>return</code>能直接终止可执行代码的执行，因此会直接将当前的上下文弹出栈。</p>          </div><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720143216.png" alt=""></p><blockquote><p>详细了解这个过程之后，我们就可以对执行上下文总结一些结论了</p></blockquote><ol><li>单线程</li><li>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li><li>函数的执行上下文的个数没有限制</li><li>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此</li></ol><blockquote><p>为了巩固一下<code>执行上下文</code>的理解，我们来绘制一个简单的闭包例子。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">  var n = 999</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>() &#123;</span><br><span class="line">    alert(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> f2</span><br><span class="line">&#125;</span><br><span class="line">var result = f1()</span><br><span class="line">result()</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>f1</code>中的函数<code>f2</code>在<code>f1</code>的可执行代码中，并没有被调用执行，因此执行<code>f1</code>时，<code>f2</code>不会创建新的上下文，而直到<code>result</code>执行时，才创建了一个新的。具体演变过程如下。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200720144635.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p><code>执行上下文</code>在我们日常中是经常遇到的，想要让自己的技术更上一层的话，理解<code>执行上下文</code>是必不可少的一步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们在JavaScript学习初期，或者在面试的时候通常会遇到&lt;code&gt;执行上下文&lt;/code&gt;相关的思考题，今天，我们就来学习一下什么是&lt;code&gt;执行上下文&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="执行上下文" scheme="https://www.chenkl.vip/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>前端基础进阶学习(一)--内存空间</title>
    <link href="https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)--%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"/>
    <id>https://www.chenkl.vip/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)--%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/</id>
    <published>2020-07-06T16:40:33.000Z</published>
    <updated>2020-08-22T02:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为<code>JavaScript</code>具有自动垃圾回收机制，所以对于我们前端来讲，内存空间并不是一个经常提及的概念，久而久之，我们会认为内存空间的概念在JavaScript的学习中并不是那么重要，导致了许多知识理解并不明白。在学习内存空间之前，我们需要对三种数据结构有一个清晰的理解，分别是<code>堆(heap)</code>、<code>栈(stack)</code>以及<code>队列(queue)</code></p></blockquote><a id="more"></a><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><blockquote><p>JavaScript中并没有严格意义上区分栈内存和堆内存，因为我们可以简单的理解为JavaScript的所有数据都存在堆内存中。但是在一些特定场景下，我们仍然需要基于栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文，执行上下文的执行顺序借用了栈数据结构的存取方式。因此理解栈数据结构的原理与特点十分重要。</p></blockquote><blockquote><p>要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析，如下图：</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200706165813.png" alt=""></p><blockquote><p>图中可以很详细的解释了栈空间的存储原理，处于盒子中最顶层的乒乓球5，它一定是最后被放进去的，但可以最先被使用。而我们想要使用乒乓球1，就必须将上面的4个乒乓球取出来，这就是栈空间的<code>先进先出，后进后出</code>的特点。</p></blockquote><h2 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h2><blockquote><p>对数据结构是一种树状结构，它的存取数据的方式，则与书架与书非常相似。</p></blockquote><blockquote><p>比如，书虽然也整齐的放在书架上，但是我们只要知道了书的名字，就可以很方便的取出我们想要的书，而不用像取乒乓球一样，非得讲上面的所有球都拿出来才能取到中间某个我们想要的乒乓球。就好比在JavaScripton格式的数据中，我们存储的<code>key-value</code>是可以无序的，因为顺序的不同并不影响我们使用。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环的机智到底是怎么回事。</p></blockquote><blockquote><p>队列是一种先进先出(FIFO)的数据结构，正如排队过安检的一样，排在队伍前面的人一定是最先过安检的人。用下图可以清楚的理解队列的原理：</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200708105534.png" alt=""></p><h2 id="变量对象与基础数据类型"><a href="#变量对象与基础数据类型" class="headerlink" title="变量对象与基础数据类型"></a>变量对象与基础数据类型</h2><blockquote><p>JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。</p></blockquote><blockquote><p>严格意义上来说，变量对象也是存放在堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其与堆内存区分开来。</p></blockquote><blockquote><p>基础数据类型都是一些简单的数据段，在<code>ES6</code>之前，JavaScript中有五种基础数据类型，分别是<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>。基础数据类型都是按照值访问，我们可以直接操作保存在变量中的实际值。</p></blockquote><h2 id="引用数据类型与堆内存"><a href="#引用数据类型与堆内存" class="headerlink" title="引用数据类型与堆内存"></a>引用数据类型与堆内存</h2><blockquote><p>JavaScript的引用数据类型，比如数据<code>Array</code>，它们值的大小是不固定的，引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的数据，因为我们不能直接操作对象的堆内存空间，在操作对象时，实际上是在操作对象的引用而不是实际对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值有相关联。</p></blockquote><blockquote><p>为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a1 = 0;   // 变量对象</span><br><span class="line">var a2 = <span class="string">'this is string'</span>; // 变量对象</span><br><span class="line">var a3 = null; // 变量对象</span><br><span class="line"></span><br><span class="line">var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中</span><br><span class="line">var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中</span><br></pre></td></tr></table></figure><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200708110717.png" alt=""></p><blockquote><p>当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用(或者地址指针)，然后再从堆内存中取得我们需要的数据。</p></blockquote><blockquote><p>理解了JavaScript的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点</p></blockquote><blockquote><p>在前端面试中我们常常会遇到这样一个类似的题目</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// demo01.js</span><br><span class="line">var a = 20;</span><br><span class="line">var b = a;</span><br><span class="line">b = 30;</span><br><span class="line"></span><br><span class="line">// 这时a的值是多少？</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// demo02.js</span><br><span class="line">var m = &#123; a: 10, b: 20 &#125;</span><br><span class="line">var n = m;</span><br><span class="line">n.a = 15;</span><br><span class="line"></span><br><span class="line">// 这时m.a的值是多少</span><br></pre></td></tr></table></figure><blockquote><p>在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。<code>var b = a</code>执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了，如下图：</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200708111314.png" alt=""></p><blockquote><p>所以我们修改了b的值以后，a的值并不会发生变化。</p></blockquote><blockquote><p>在demo02中，我们通过<code>var n = m</code>执行一次复制引用类型的操作，引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针，当地址指针向相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个：</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200708111913.png" alt=""></p><h2 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h2><blockquote><p>因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理，但是根据以往的开发经验，了解内存机制有助于自己的清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。</p></blockquote><blockquote><p>JavaScript的内存生命周期</p></blockquote><ol><li>分配到你需要的内存</li><li>使用分配到的内存(读、写)</li><li>不需要时将其释放、归还</li></ol><blockquote><p>为了便于理解，我们可以看看以下例子</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;  // 在内存中给数值变量分配空间</span><br><span class="line">alert(a + 100);  // 使用内存</span><br><span class="line">a = null; // 使用完毕之后，释放内存空间</span><br></pre></td></tr></table></figure><blockquote><p>第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配，第三步释放内存空间则是我们需要重点理解的一个点。</p></blockquote><blockquote><p>JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么？其实很简单，就是找出那些不在继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定时间段就执行一次释放操作。</p></blockquote><blockquote><p>在JavaScript中，最常用的是通过<code>标记清除</code>的算法来找到哪些对象不再继续使用，因为<code>a = null</code>其实仅仅只是做了一个释放引用的操作，让a原本对应的值失去引用，脱离执行环境，这个值会在下一次的垃圾收集器执行操作的时候被找到并释放，而在适当的时候解除引用，是为页面获得更好的性能提升。</p></blockquote><div class="note warning">            <p>需要注意的是，在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要释放内存空间则很难判断，因此在我们的开发中，原则上应该避免使用全局变量。</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为&lt;code&gt;JavaScript&lt;/code&gt;具有自动垃圾回收机制，所以对于我们前端来讲，内存空间并不是一个经常提及的概念，久而久之，我们会认为内存空间的概念在JavaScript的学习中并不是那么重要，导致了许多知识理解并不明白。在学习内存空间之前，我们需要对三种数据结构有一个清晰的理解，分别是&lt;code&gt;堆(heap)&lt;/code&gt;、&lt;code&gt;栈(stack)&lt;/code&gt;以及&lt;code&gt;队列(queue)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="https://www.chenkl.vip/tags/javaScript/"/>
    
      <category term="前端进阶" scheme="https://www.chenkl.vip/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
      <category term="内存空间" scheme="https://www.chenkl.vip/tags/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab如何配置邮件服务</title>
    <link href="https://www.chenkl.vip/Gitlab%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"/>
    <id>https://www.chenkl.vip/Gitlab%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-06-19T15:33:56.000Z</published>
    <updated>2020-07-25T07:19:35.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章主要记录了如何配置<code>gitlab</code>的邮件服务（以QQ个人邮箱为例）。</p></blockquote><a id="more"></a><h2 id="开通授权码"><a href="#开通授权码" class="headerlink" title="开通授权码"></a>开通授权码</h2><blockquote><p>设置–&gt;账户–&gt;smtp–&gt;密保验证–&gt;验证成功后返回授权码。保存好授权码</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200619155223.png" alt=""></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><blockquote><p>打开<code>/etc/gitlab/gitlab.rb</code>，在文件最底下添加以下内容，或者也可以找到对应位置进行修改：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[<span class="string">'smtp_enable'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_address'</span>] = <span class="string">"smtp.qq.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_port'</span>] = 465</span><br><span class="line">gitlab_rails[<span class="string">'smtp_user_name'</span>] = <span class="string">"xxxxx@qq.com"</span> // 个人QQ邮箱</span><br><span class="line">gitlab_rails[<span class="string">'smtp_password'</span>] = <span class="string">"xxxxxx"</span> // 16位授权码</span><br><span class="line">gitlab_rails[<span class="string">'smtp_domain'</span>] = <span class="string">"qq.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_authentication'</span>] = <span class="string">"login"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_enable_starttls_auto'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_tls'</span>] = <span class="literal">true</span></span><br><span class="line">user[<span class="string">'git_user_email'</span>] = <span class="string">"xxxxx@qq.com"</span> // 个人QQ邮箱</span><br><span class="line">gitlab_rails[<span class="string">'gitlab_email_from'</span>] = <span class="string">"xxxxx@qq.com"</span> // 个人QQ邮箱</span><br></pre></td></tr></table></figure><h2 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><h2 id="测试邮件服务是否正常"><a href="#测试邮件服务是否正常" class="headerlink" title="测试邮件服务是否正常"></a>测试邮件服务是否正常</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这步可能需要等待一点时间。</span></span><br><span class="line">gitlab-rails console</span><br><span class="line"></span><br><span class="line">Notify.test_email(<span class="string">'接收方邮件地址'</span>,<span class="string">'邮件标题'</span>,<span class="string">'邮件内容'</span>).deliver_now</span><br></pre></td></tr></table></figure><blockquote><p>发送成功之后，我们就可以收到邮件了：</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200619155949.png" alt=""></p><blockquote><p>到此我们就可以愉快的使用邮件服务了。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><div class="note info">            <p>如果邮件发送失败，要么就是465端口未开放，要么就是授权码不正确，需要看官们自行去解决一下。</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇文章主要记录了如何配置&lt;code&gt;gitlab&lt;/code&gt;的邮件服务（以QQ个人邮箱为例）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="gitlab" scheme="https://www.chenkl.vip/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="https://www.chenkl.vip/tags/gitlab/"/>
    
      <category term="邮件配置" scheme="https://www.chenkl.vip/tags/%E9%82%AE%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab私有化仓库如何汉化</title>
    <link href="https://www.chenkl.vip/Gitlab%E7%A7%81%E6%9C%89%E5%8C%96%E4%BB%93%E5%BA%93%E5%A6%82%E4%BD%95%E6%B1%89%E5%8C%96/"/>
    <id>https://www.chenkl.vip/Gitlab%E7%A7%81%E6%9C%89%E5%8C%96%E4%BB%93%E5%BA%93%E5%A6%82%E4%BD%95%E6%B1%89%E5%8C%96/</id>
    <published>2020-06-19T14:59:16.000Z</published>
    <updated>2020-07-25T07:19:35.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前讲到了如何基于<code>gitlab</code>搭建公司内部私有仓库，这篇文章主要讲如何进行<code>gitlab</code>的汉化操作。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>对于如何搭建<code>gitlab</code>的私有仓库，可以参考我之前写的 <a href="https://www.chenkl.vip/%E5%9F%BA%E4%BA%8EGitlab%E6%90%AD%E5%BB%BA%E5%85%AC%E5%8F%B8%E7%BA%A7%E5%86%85%E9%83%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/#more">基于Gitlab搭建公司级内部私有仓库</a>，本篇文章主要讲如何进行<code>gitlab</code>的汉化。</p></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如何没有当前目录，可以自行创建一个，或者可以放到自己想放的地方</span></span><br><span class="line"><span class="built_in">cd</span> /data/src/</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://gitlab.com/xhang/gitlab.git</span><br></pre></td></tr></table></figure><blockquote><p>如果提示<code>git: command not found</code>，我们需要先进行安装<code>git</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://gitlab.com/xhang/gitlab.git</span><br></pre></td></tr></table></figure><h2 id="停止gitlab"><a href="#停止gitlab" class="headerlink" title="停止gitlab"></a>停止gitlab</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop</span><br></pre></td></tr></table></figure><h2 id="汉化操作"><a href="#汉化操作" class="headerlink" title="汉化操作"></a>汉化操作</h2><h3 id="查看改汉化补丁版本"><a href="#查看改汉化补丁版本" class="headerlink" title="查看改汉化补丁版本"></a>查看改汉化补丁版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat gitlab/VERSION</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10.7.3</span></span><br></pre></td></tr></table></figure><h3 id="获取gitlab汉化包"><a href="#获取gitlab汉化包" class="headerlink" title="获取gitlab汉化包"></a>获取gitlab汉化包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> gitlab/</span><br><span class="line"></span><br><span class="line">git diff origin/10-7-stable origin/10-7-stable-zh &gt; /tmp/10.7.diff</span><br></pre></td></tr></table></figure><h3 id="更新补丁到gitlab中"><a href="#更新补丁到gitlab中" class="headerlink" title="更新补丁到gitlab中"></a>更新补丁到gitlab中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install patch</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line"></span><br><span class="line">patch -d/opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.7.diff</span><br></pre></td></tr></table></figure><h3 id="重新配置gitlab"><a href="#重新配置gitlab" class="headerlink" title="重新配置gitlab"></a>重新配置gitlab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><blockquote><p>不出意外的话，我们重新打开<code>gitlab地址</code>，出现以下页面，就说明我们汉化成功了。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200619152022.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><div class="note info">            <p><code>gitlab</code>的汉化操作算是比较简单的，有兴趣的看官可以自行去实践一下。一般来说不会遇到什么大问题的。</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前讲到了如何基于&lt;code&gt;gitlab&lt;/code&gt;搭建公司内部私有仓库，这篇文章主要讲如何进行&lt;code&gt;gitlab&lt;/code&gt;的汉化操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="gitlab" scheme="https://www.chenkl.vip/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="https://www.chenkl.vip/tags/gitlab/"/>
    
      <category term="gitlab汉化" scheme="https://www.chenkl.vip/tags/gitlab%E6%B1%89%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基于Gitlab搭建公司级内部私有仓库</title>
    <link href="https://www.chenkl.vip/%E5%9F%BA%E4%BA%8EGitlab%E6%90%AD%E5%BB%BA%E5%85%AC%E5%8F%B8%E7%BA%A7%E5%86%85%E9%83%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://www.chenkl.vip/%E5%9F%BA%E4%BA%8EGitlab%E6%90%AD%E5%BB%BA%E5%85%AC%E5%8F%B8%E7%BA%A7%E5%86%85%E9%83%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2020-06-19T11:05:05.000Z</published>
    <updated>2020-07-25T07:19:35.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个比较有规模的公司，实际上是需要有一个公司内部私有化的仓库来管理源码。所以在这里记录一下如何搭建一个公司内部的gitlab平台，供公司内部人员使用。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="note warning">            <ol><li>本篇文章是以<code>centos 7</code>和<code>gitlab 10</code>为搭建基础来编写的。</li><li>观看本篇文章，需要对<code>linux</code>系统有一定的基础知识。</li><li>如需实践，需要有一台<code>linux</code>服务器，这里我自己使用的是<code>腾讯云</code>1核2G的云服务器（该服务器只是为了实践用的，不代表安装使用<code>gitlab</code>的最低配置）。</li></ol>          </div><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><blockquote><p>GitLab 10.x之后添加多了一些依赖，并且要启动sshd服务，所以我们先添加依赖，启动sshd，为防火墙添加服务。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install -y curl policycoreutils-python openssh-server openssh-clients</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line">systemctl start sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 防火墙这2步可以不用管</span></span><br><span class="line"><span class="comment"># firewall-cmd –permanent –add-service=http</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl reload firewalld</span></span><br></pre></td></tr></table></figure><blockquote><p>gitlab配置需要用到邮件发送，所以还要再安装postfix。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install postfix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完之后启动</span></span><br><span class="line">systemctl start postfix</span><br></pre></td></tr></table></figure><div class="note info">            <p>启动过程中如果报错：Job for postfix.service failed because the control process exited with error code. See “systemctl status postfix.service” and “journalctl -xe” for details.</p><p>解决办法，<code>/etc/postfix/main.cf</code>，修改以下两处地方：</p>          </div><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200619133102.png" alt=""></p><blockquote><p>修改完成后，再次启动，就不会报错了，设置<code>postfix</code>为开机自启动。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> postfix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动状态,看到 Active: active (running) 就是已经正常启动了</span></span><br><span class="line">systemctl status postfix</span><br></pre></td></tr></table></figure><h2 id="gitlab安装"><a href="#gitlab安装" class="headerlink" title="gitlab安装"></a>gitlab安装</h2><blockquote><p>下载rpm包并安装。可根据实际需要安装指定版本。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/gitlab</span><br><span class="line"></span><br><span class="line">mv gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm /usr/<span class="built_in">local</span>/gitlab/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/gitlab/</span><br><span class="line"></span><br><span class="line">rpm -i gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><div class="note info">            <p>warning: gitlab-ce-11.6.3-ce.0.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEY<br>error: Failed dependencies:<br>    policycoreutils-python is needed by gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm<br>如果出现上面这个报错就执行：</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install policycoreutils-python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后重新运行</span></span><br><span class="line">rpm -i gitlab-ce-11.6.3-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>如果不出意外的话，到这里我们就可以在控制台上看到以下提示，这说明我们已经安装成功了：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">It looks like GitLab has not been configured yet; skipping the upgrade script.</span><br><span class="line"></span><br><span class="line">       *.                  *.</span><br><span class="line">      ***                 ***</span><br><span class="line">     *****               *****</span><br><span class="line">    .******             *******</span><br><span class="line">    ********            ********</span><br><span class="line">   ,,,,,,,,,***********,,,,,,,,,</span><br><span class="line">  ,,,,,,,,,,,*********,,,,,,,,,,,</span><br><span class="line">  .,,,,,,,,,,,*******,,,,,,,,,,,,</span><br><span class="line">      ,,,,,,,,,*****,,,,,,,,,.</span><br><span class="line">         ,,,,,,,****,,,,,,</span><br><span class="line">            .,,,***,,,,</span><br><span class="line">                ,*,.</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     _______ __  __          __</span><br><span class="line">    / ____(_) /_/ /   ____ _/ /_</span><br><span class="line">   / / __/ / __/ /   / __`/ __ \</span><br><span class="line">  / /_/ / / /_/ /___/ /_/ / /_/ /</span><br><span class="line">  \____/_/\__/_____/\__,_/_.___/</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">Thank you <span class="keyword">for</span> installing GitLab!</span><br><span class="line">GitLab was unable to detect a valid hostname <span class="keyword">for</span> your instance.</span><br><span class="line">Please configure a URL <span class="keyword">for</span> your GitLab instance by setting`external_url`</span><br><span class="line">configuration <span class="keyword">in</span> /etc/gitlab/gitlab.rb file.</span><br><span class="line">Then, you can start your GitLab instance by running the following <span class="built_in">command</span>:</span><br><span class="line">  sudo gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line">For a comprehensive list of configuration options please see the Omnibus GitLab readme</span><br><span class="line">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md</span><br></pre></td></tr></table></figure><h2 id="配置并启动gitlab-ce"><a href="#配置并启动gitlab-ce" class="headerlink" title="配置并启动gitlab-ce"></a>配置并启动gitlab-ce</h2><blockquote><p><code>gitlab</code>安装完成后，需要设置一个访问地址（或域名），打开<code>/etc/gitlab/gitlab.rb</code>，将默认的<code>external_url = &#39;http://git.example.com&#39;</code>修改为自己的IP地址:<code>http://xxx.xx.xxx.xx</code></p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200619134650.png" alt=""></p><blockquote><p>保存之后，执行以下命令，让配置生效</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Gitlab</span></span><br><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><blockquote><p>启动完成后，在浏览器输入上面修改的IP,就是<code>gitlab</code>的登录首页了，如果出现<code>502</code>页面，就是端口被占用了或者端口为开放。需要自行去设置或者开放端口。</p></blockquote><blockquote><p>当IP地址生效后，我们打开之后就可以看到以下的页面，证明我们<code>gitlab</code>安装并启动成功了。</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/1070438-20190116110755861-1754218775.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><div class="note info">            <p>以上就是我自己实践并记录的一些踩坑之路，搭建完之后，我们就可以愉快的进行玩耍了。后续还会专门写如何<code>汉化</code>以及如何配置<code>邮件服务</code>。</p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个比较有规模的公司，实际上是需要有一个公司内部私有化的仓库来管理源码。所以在这里记录一下如何搭建一个公司内部的gitlab平台，供公司内部人员使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="gitlab" scheme="https://www.chenkl.vip/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="https://www.chenkl.vip/tags/gitlab/"/>
    
      <category term="私有仓库" scheme="https://www.chenkl.vip/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli3.0多环境配置</title>
    <link href="https://www.chenkl.vip/vue-cli3-0%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.chenkl.vip/vue-cli3-0%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-30T17:34:59.000Z</published>
    <updated>2020-07-25T07:19:35.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常开发中，我们通常会遇到不同环境的发包，所以在这里记录一下如何进行多环境配置。</p></blockquote><a id="more"></a><h2 id="新建环境配置文件"><a href="#新建环境配置文件" class="headerlink" title="新建环境配置文件"></a>新建环境配置文件</h2><blockquote><p>我们需要在项目的根目录下新建环境配置文件，在这里我们以<code>development</code>开发环境、<code>production</code>生产环境<code>test</code>测试环境为例</p></blockquote><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200530174258.png" alt=""></p><blockquote><p>之后我们在每个文件中添加以下代码</p></blockquote><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'development'</span></span><br><span class="line">VUE_APP_CURENV = <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'production'</span></span><br><span class="line">VUE_APP_CURENV = <span class="string">'pro'</span></span><br></pre></td></tr></table></figure><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'test'</span></span><br><span class="line">VUE_APP_CURENV = <span class="string">'test'</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>配置完多环境文件之后，具体需要进行什么操作由各位看官们根据项目自行决定，这里不做过多的阐述。接下来我们还需要在<code>package.json</code>进行修改</p>          </div><h2 id="修改-package-json-文件"><a href="#修改-package-json-文件" class="headerlink" title="修改 package.json 文件"></a>修改 package.json 文件</h2><p><img src="https://sanyuanda.oss-cn-hangzhou.aliyuncs.com/imgs/QQ%E5%9B%BE%E7%89%8720200530175026.png" alt=""></p><blockquote><p>以上修改为多环境的打包命令，如果需要发包<code>测试环境</code>只需执行以下命令：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>其他环境同理，如果嫌一个个输入命令比较麻烦，可以像我一样，使用<code>npm run all</code>进行三个环境的打包。</p>          </div><h2 id="不同环境的包名"><a href="#不同环境的包名" class="headerlink" title="不同环境的包名"></a>不同环境的包名</h2><blockquote><p>因为默认打包都是<code>dist</code>包名，所以不是很好区分是哪个环境的包，所以我们在<code>vue.config.js</code>里面进行配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputDir:`dist-<span class="variable">$&#123;process.env.VUE_APP_CURENV&#125;</span>-<span class="variable">$&#123;formatTime(new Date(), 'yyyyMMddHHmmss')&#125;</span>`,</span><br></pre></td></tr></table></figure><div class="note info">            <p>可根据自己的实际情况进行修改设置，这里只提供一个例子。这样，我们每次打包出来，就很好的区分了是哪个环境的包了。</p>          </div><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>在日常开发中，多环境配置还是很实用的，有兴趣的可以去实践一下。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在日常开发中，我们通常会遇到不同环境的发包，所以在这里记录一下如何进行多环境配置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://www.chenkl.vip/categories/vue/"/>
    
    
      <category term="vue" scheme="https://www.chenkl.vip/tags/vue/"/>
    
      <category term="vue-cli" scheme="https://www.chenkl.vip/tags/vue-cli/"/>
    
      <category term="多环境" scheme="https://www.chenkl.vip/tags/%E5%A4%9A%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
</feed>
